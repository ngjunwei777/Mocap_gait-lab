<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gait Biodynamics Lab - Camera + High-FPS Video Upload</title>
  <meta name="description" content="Per-step running gait analysis with MoveNet. Camera + video upload, XLSX export, PNG snapshot, seek + frame-step, GRF-time proxy curves, and gait issue tags.">

  <!--
    Gait Biodynamics Lab
    Copyright (c) 2025 Ng Jun Wei. All rights reserved.
    Unauthorized copying, modification, distribution, or use of this code, in whole or in part, is prohibited without prior written permission.
  -->

  <!-- TFJS + Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:10px; font-size:2.35em; }
    .subtitle { text-align:center; color:#666; margin-bottom:16px; }

    .status { padding:10px; border-radius:8px; margin-bottom:16px; text-align:center; font-weight:650; }
    .status.loading { background:#fff3cd; color:#856404; }
    .status.ready { background:#d4edda; color:#155724; }
    .status.error { background:#f8d7da; color:#721c24; }

    .loading-spinner {
      display:inline-block;
      width:18px; height:18px;
      border:3px solid rgba(102,126,234,0.25);
      border-radius:50%;
      border-top-color:#667eea;
      animation:spin 1s linear infinite;
      vertical-align:-3px;
      margin-right:8px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .info-section { padding:16px; background:#f8f9fa; border-radius:14px; }
    .info-section h3 { color:#667eea; margin-bottom:10px; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap:12px; }
    label { display:block; margin-bottom:6px; font-weight:650; color:#666; }
    select, input[type="number"] {
      width:100%;
      padding:10px;
      border:2px solid #667eea;
      border-radius:8px;
      font-size:14px;
      outline:none;
    }
    .hint { margin-top:8px; font-size:12px; color:#666; line-height:1.35; }

    .main-content {
      display:grid;
      grid-template-columns: 2fr 1fr;
      gap: 22px;
      margin-top: 14px;
    }
    @media (max-width: 968px) {
      .main-content { grid-template-columns: 1fr; }
      h1 { font-size: 1.8em; }
    }

    .video-section { position:relative; }
    #videoContainer {
      position:relative;
      width:100%;
      background:#000;
      border-radius:15px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #webcam { width:100%; display:block; background:#000; }
    #canvas {
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
    }
    .fps-indicator {
      position:absolute;
      top:10px; right:10px;
      background: rgba(0,0,0,0.7);
      color:#0f0;
      padding:8px 12px;
      border-radius:8px;
      font-weight:700;
      font-size:13px;
      z-index:10;
    }

    .controls { display:flex; gap:10px; margin-top:14px; flex-wrap:wrap; }
    button {
      flex:1;
      min-width:170px;
      padding: 12px 14px;
      font-size: 14px;
      font-weight: 800;
      border:none;
      border-radius:10px;
      cursor:pointer;
      transition: transform 0.15s ease, opacity 0.15s ease;
      text-transform: uppercase;
      letter-spacing: 0.7px;
    }
    button:disabled { opacity:0.55; cursor:not-allowed; }
    button:hover:not(:disabled) { transform: translateY(-1px); }

    #startCamBtn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; }
    #loadVideoBtn { background: #f39c12; color:#1f1f1f; }
    #playPauseBtn { background: #2c3e50; color:white; }
    #stopBtn { background: #e74c3c; color:white; }
    #recordBtn { background: #27ae60; color:white; }
    #recordBtn.recording { background:#e74c3c; animation:pulse 1.5s infinite; }
    #exportBtn { background: #3498db; color:white; }
    #snapshotBtn { background: #8e44ad; color:white; }
    @keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.7; } }

    .analysis-panel {
      background:#f8f9fa;
      border-radius:15px;
      padding:16px;
      height: fit-content;
    }
    .pill {
      display:inline-block;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:900;
      color:white;
      background:#667eea;
      margin-left:8px;
    }

    .gait-phase {
      background:white;
      padding:14px;
      border-radius:12px;
      margin-bottom:12px;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }
    .metric-label { font-size:12px; color:#666; text-transform:uppercase; letter-spacing:1px; margin-bottom:5px; }
    .metric-value { font-size:18px; font-weight:900; color:#222; }
    .metric-unit { font-size:13px; color:#999; margin-left:6px; font-weight:700; }

    .phase-indicator { display:flex; justify-content:space-between; margin-top:10px; }
    .phase-dot {
      width:40px; height:40px;
      border-radius:50%;
      background:#e0e0e0;
      display:flex; align-items:center; justify-content:center;
      font-size:10px; font-weight:900; color:#999;
      transition: all 0.25s ease;
    }
    .phase-dot.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color:white;
      transform: scale(1.14);
    }

    .metrics { display:grid; gap:10px; margin-top:10px; }
    .metric-card {
      background:white;
      padding:12px;
      border-radius:12px;
      border-left:4px solid #667eea;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }

    .issues-list {
      background:white;
      padding:12px;
      border-radius:12px;
      max-height: 210px;
      overflow-y:auto;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }
    .issue-item { padding:9px; margin-bottom:8px; border-radius:7px; font-size:13px; display:flex; gap:8px; align-items:flex-start; }
    .issue-item.warning { background:#fff3cd; border-left:3px solid #ffc107; }
    .issue-item.critical { background:#f8d7da; border-left:3px solid #dc3545; }

    .tag {
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:900;
      color:#fff;
      line-height:1.6;
      white-space:nowrap;
      transform: translateY(1px);
    }
    .tag.overstrider { background:#2c3e50; }
    .tag.bouncer { background:#8e44ad; }
    .tag.collapser { background:#16a085; }
    .tag.crosser { background:#e67e22; }
    .tag.generic { background:#667eea; }

    .charts-section {
      margin-top:18px;
      padding:16px;
      background:#f8f9fa;
      border-radius:15px;
    }
    .charts-section h3 { color:#667eea; margin-bottom:12px; }
    .chart-container {
      background:white;
      padding:14px;
      border-radius:12px;
      margin-bottom:12px;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }
    .chart-wrap { height: 260px; } /* IMPORTANT: give Chart.js real height */
    .chart-wrap.tall { height: 320px; }
    .chart-container canvas { width:100% !important; height:100% !important; }

    .tiny { font-size:12px; color:#666; margin-top:10px; line-height:1.35; }
    .row-note { margin-top:8px; font-size:12px; color:#666; }

    /* Video controls panel */
    .video-controls {
      margin-top: 12px;
      background: #f8f9fa;
      border-radius: 12px;
      padding: 12px;
      display: none;
    }
    .vc-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .seek-row {
      display: grid;
      grid-template-columns: 90px 1fr 140px;
      gap: 10px;
      align-items: center;
    }
    input[type="range"] { width: 100%; }
    .vc-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .vc-buttons button {
      min-width: 140px;
      flex: 1;
      padding: 10px 12px;
      font-size: 13px;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      color: #333;
    }

    /* Step selector for GRF curve */
    .step-select {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .step-select select {
      padding: 10px;
      border: 2px solid #667eea;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      width: 100%;
    }

    footer {
      margin-top: 14px;
      text-align:center;
      color:#666;
      font-size:12px;
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ Gait Biodynamics Lab</h1>
  <p class="subtitle">Camera (set 120fps) + Upload High-FPS Video (e.g., 240fps) ‚Ä¢ Seek + Frame-step ‚Ä¢ Per-step GRF-time proxy curves ‚Ä¢ Application is developed by Ng Jun Wei</p>

  <div id="status" class="status loading"><span class="loading-spinner"></span> Initializing‚Ä¶</div>

  <div class="info-section">
    <h3>üë§ Subject & View</h3>
    <div class="grid">
      <div>
        <label>View Mode</label>
        <select id="viewMode">
          <option value="sagittal" selected>Sagittal (Side View)</option>
          <option value="frontal">Frontal (Front/Back View)</option>
        </select>
        <div class="hint">Sagittal: overstride ‚Ä¢ Frontal: pelvic tilt + knee drift + crossover gait at IC.</div>
      </div>
      <div>
        <label>Sex</label>
        <select id="subjectSex">
          <option value="male">Male</option>
          <option value="female">Female</option>
        </select>
      </div>
      <div>
        <label>Age (years)</label>
        <input type="number" id="subjectAge" min="1" max="120" value="30">
      </div>
      <div>
        <label>Mass (kg)</label>
        <input type="number" id="subjectMass" min="20" max="300" step="0.1" value="70">
      </div>
      <div>
        <label>Height (cm) (used for spatial calibration)</label>
        <input type="number" id="subjectHeight" min="100" max="250" step="0.1" value="170">
      </div>
    </div>
    <div class="tiny">
      Tip: true 240fps is best via uploaded slow-mo video. Browser decoding may deliver fewer frames on some devices, but seek + frame-step helps review precisely.
    </div>
  </div>

  <div class="main-content">
    <div class="video-section">
      <div id="videoContainer">
        <div class="fps-indicator" id="fpsDisplay">FPS: 0</div>
        <video id="webcam" playsinline muted></video>
        <canvas id="canvas"></canvas>
      </div>

      <div class="controls">
        <button id="startCamBtn" disabled>Start Camera</button>
        <button id="loadVideoBtn" disabled>Upload Video</button>
        <button id="playPauseBtn" disabled>Play</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="recordBtn" disabled>Start Recording</button>
        <button id="exportBtn" disabled>Export XLSX</button>
        <button id="snapshotBtn" disabled>Snapshot PNG</button>
      </div>

      <!-- Uploaded video controls -->
      <div class="video-controls" id="videoControlsPanel">
        <div class="vc-row">
          <div class="seek-row">
            <div class="mono">Seek</div>
            <input id="seekBar" type="range" min="0" max="1000" value="0" step="1">
            <div class="mono" id="timeLabel">0.000 / 0.000</div>
          </div>

          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap: 12px;">
            <div>
              <label>Assumed Video FPS (for frame-step)</label>
              <input id="assumedFps" type="number" min="10" max="1000" step="1" value="240">
              <div class="hint">If your video is 120fps ‚Äúnormal‚Äù, set to 120. This only affects ¬±1-frame stepping.</div>
            </div>
            <div>
              <label>Frame Step Size</label>
              <select id="frameStepMode">
                <option value="1" selected>¬±1 frame</option>
                <option value="2">¬±2 frames</option>
                <option value="5">¬±5 frames</option>
              </select>
              <div class="hint">Use larger steps if your device lags during scrubbing.</div>
            </div>
          </div>

          <div class="vc-buttons">
            <button id="stepBackBtn" disabled>‚óÄÔ∏é -Frame</button>
            <button id="stepFwdBtn" disabled>Frame+ ‚ñ∂Ô∏é</button>
            <button id="skipBackBtn" disabled>‚óÄÔ∏é -0.1s</button>
            <button id="skipFwdBtn" disabled>+0.1s ‚ñ∂Ô∏é</button>
          </div>

          <div class="mono" id="videoMetaLabel">Video: (not loaded)</div>
        </div>
      </div>

      <input id="videoFile" type="file" accept="video/*" style="display:none;">
      <div class="row-note" id="sourceNote">Source: none</div>
    </div>

    <div class="analysis-panel">
      <h3 style="color:#667eea; margin-bottom:10px;">
        Real-Time (Per-Step)
        <span class="pill" id="modePill">SAGITTAL</span>
        <span class="pill" id="sourcePill" style="background:#2c3e50;">NONE</span>
      </h3>

      <div class="gait-phase">
        <div class="metric-label">Current Phase</div>
        <div class="metric-value" id="gaitPhase">Standing</div>
        <div class="phase-indicator">
          <div class="phase-dot" id="phase1">IC</div>
          <div class="phase-dot" id="phase2">MS</div>
          <div class="phase-dot" id="phase3">TO</div>
          <div class="phase-dot" id="phase4">SW</div>
        </div>
        <div class="tiny" style="margin-top:10px;">IC: Initial Contact ‚Ä¢ MS: Mid Stance ‚Ä¢ TO: Toe Off ‚Ä¢ SW: Swing</div>
      </div>

      <div class="metrics">
        <div class="metric-card">
          <div class="metric-label">Cadence (last ~8 IC)</div>
          <div class="metric-value" id="cadence">0<span class="metric-unit">steps/min</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Stance Time Avg (last ~6)</div>
          <div class="metric-value" id="stanceTime">0<span class="metric-unit">s</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Swing Time Avg (last ~6)</div>
          <div class="metric-value" id="swingTime">0<span class="metric-unit">s</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Stride Length Avg (last ~6)</div>
          <div class="metric-value" id="strideLength">0<span class="metric-unit">cm</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Knee Flexion Mid-Stance (L) - last</div>
          <div class="metric-value" id="kneeMSL">0<span class="metric-unit">¬∞</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Knee Flexion Mid-Stance (R) - last</div>
          <div class="metric-value" id="kneeMSR">0<span class="metric-unit">¬∞</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Pelvic Tilt (Lateral) - last</div>
          <div class="metric-value" id="pelvicTilt">0<span class="metric-unit">¬∞</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Vertical Oscillation (VO) - live</div>
          <div class="metric-value" id="vertOsc">0<span class="metric-unit">cm</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label" id="modeMetricLabel">Overstride Risk (last IC)</div>
          <div class="metric-value" id="modeMetricValue">Low</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">GRF Peak (last step, proxy)</div>
          <div class="metric-value" id="grfPeak">0<span class="metric-unit">BW</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">GRF Time-to-Peak (last step, proxy)</div>
          <div class="metric-value" id="grfTTP">0<span class="metric-unit">ms</span></div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="metric-label">Detected Issues (per-step)</div>
        <div class="issues-list" id="issuesList">
          <div style="text-align:center; color:#999; padding:18px;">No issues detected yet</div>
        </div>
      </div>

      <div class="tiny">
        GRF proxy curve uses ankle vertical deceleration during stance (normalized to BW proxy). It‚Äôs not a true force plate.
      </div>
    </div>
  </div>

  <div class="charts-section">
    <h3>üìä Charts (smoothed with low-pass filter)</h3>

    <div class="chart-container">
      <div class="chart-wrap"><canvas id="strideChart"></canvas></div>
    </div>

    <div class="chart-container">
      <div class="chart-wrap"><canvas id="stanceChart"></canvas></div>
    </div>

    <div class="chart-container">
      <div class="chart-wrap"><canvas id="kneeMSChart"></canvas></div>
    </div>

    <div class="chart-container">
      <div class="step-select">
        <div class="mono">GRF Curve Step</div>
        <select id="stepPicker">
          <option value="">(no steps yet)</option>
        </select>
      </div>
      <div class="chart-wrap tall"><canvas id="grfCurveChart"></canvas></div>
      <div class="tiny">Shows the selected step‚Äôs stance GRF proxy curve (BW vs time from IC), lightly smoothed.</div>
    </div>
  </div>

  <footer>Copyright ¬© 2025 Ng Jun Wei. All rights reserved.</footer>
</div>

<script>
  // ============================================================
  // Environment
  // ============================================================
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  const useVFC = typeof HTMLVideoElement !== 'undefined' && 'requestVideoFrameCallback' in HTMLVideoElement.prototype;

  // ============================================================
  // DOM
  // ============================================================
  const statusDiv = document.getElementById('status');
  const fpsDisplay = document.getElementById('fpsDisplay');

  const startCamBtn = document.getElementById('startCamBtn');
  const loadVideoBtn = document.getElementById('loadVideoBtn');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const stopBtn = document.getElementById('stopBtn');
  const recordBtn = document.getElementById('recordBtn');
  const exportBtn = document.getElementById('exportBtn');
  const snapshotBtn = document.getElementById('snapshotBtn');

  const videoFile = document.getElementById('videoFile');
  const webcam = document.getElementById('webcam');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const viewModeEl = document.getElementById('viewMode');
  const modePill = document.getElementById('modePill');
  const sourcePill = document.getElementById('sourcePill');
  const sourceNote = document.getElementById('sourceNote');
  const modeMetricLabel = document.getElementById('modeMetricLabel');
  const modeMetricValue = document.getElementById('modeMetricValue');

  const subjectSexEl = document.getElementById('subjectSex');
  const subjectAgeEl = document.getElementById('subjectAge');
  const subjectMassEl = document.getElementById('subjectMass');
  const subjectHeightEl = document.getElementById('subjectHeight');

  // Uploaded video controls
  const videoControlsPanel = document.getElementById('videoControlsPanel');
  const seekBar = document.getElementById('seekBar');
  const timeLabel = document.getElementById('timeLabel');
  const assumedFpsEl = document.getElementById('assumedFps');
  const frameStepModeEl = document.getElementById('frameStepMode');
  const stepBackBtn = document.getElementById('stepBackBtn');
  const stepFwdBtn = document.getElementById('stepFwdBtn');
  const skipBackBtn = document.getElementById('skipBackBtn');
  const skipFwdBtn = document.getElementById('skipFwdBtn');
  const videoMetaLabel = document.getElementById('videoMetaLabel');

  // GRF curve selector
  const stepPicker = document.getElementById('stepPicker');

  // ============================================================
  // State
  // ============================================================
  let detector = null;
  let sourceMode = 'none'; // 'camera' | 'video' | 'none'
  let mediaStream = null;
  let videoObjectUrl = null;

  let isRunning = false;
  let isRecording = false;

  let animId = null;
  let vfcActive = false;

  let loopFrames = 0;
  let loopFpsT0 = 0;

  // ============================================================
  // Sex-specific thresholds + labels
  // ============================================================
  const TH = {
    male: {
      pelvicTiltWarn: 8,
      pelvicTiltCrit: 12,
      voWarnCm: 10,
      voCritCm: 13,
      overModerate: 0.20,
      overHigh: 0.30,
      // crossover (frontal) in fractions of hip width
      crossoverWarnHipW: 0.12,
      crossoverCritHipW: 0.18
    },
    female: {
      pelvicTiltWarn: 10,
      pelvicTiltCrit: 14,
      voWarnCm: 11,
      voCritCm: 14,
      overModerate: 0.18,
      overHigh: 0.28,
      crossoverWarnHipW: 0.10,
      crossoverCritHipW: 0.16
    }
  };

  // ============================================================
  // Per-step gait state (concurrent L/R)
  // ============================================================
  function makeFootState(side) {
    return {
      side,
      groundY: null,
      contact: false,
      prev: { t: 0, x: 0, y: 0, ok: false },
      prevVY: 0,
      active: null,
      lastTO: null,
      lastIC: null,
      lastIC_hipX: null
    };
  }

  const gait = {
    feet: { L: makeFootState('L'), R: makeFootState('R') },
    steps: [],
    icTimes: [],
    recentWindow: 6,
    vo: { baselineY: null, maxDevPx: 0, windowFrames: 0, lastVOcm: 0 },
    lastVOcmLive: 0
  };

  let detectedIssues = new Set();

  // ============================================================
  // Charts
  // ============================================================
  let strideChart, stanceChart, kneeMSChart, grfCurveChart;

  // Low-pass smoothing: EMA for step-series; SMA for GRF curve
  function emaSeries(values, alpha = 0.25) {
    let prev = null;
    return values.map(v => {
      if (v == null || !isFinite(v)) return null;
      if (prev == null) { prev = v; return v; }
      prev = alpha * v + (1 - alpha) * prev;
      return prev;
    });
  }

  function sma(values, win = 5) {
    const out = [];
    for (let i = 0; i < values.length; i++) {
      let s = 0, c = 0;
      for (let j = Math.max(0, i - win + 1); j <= i; j++) {
        const v = values[j];
        if (v == null || !isFinite(v)) continue;
        s += v; c++;
      }
      out.push(c ? (s / c) : null);
    }
    return out;
  }

  function baseChartOptions(xTitle, yTitle) {
    return {
      responsive: true,
      maintainAspectRatio: false, // key fix for "missing charts"
      animation: false,
      parsing: false,
      normalized: true,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { display: true, labels: { boxWidth: 10, boxHeight: 10 } },
        tooltip: { enabled: true }
      },
      elements: {
        point: { radius: 0, hitRadius: 10 },
        line: { borderWidth: 3, tension: 0.35 }
      },
      scales: {
        x: { title: { display: true, text: xTitle }, grid: { display: true } },
        y: { title: { display: true, text: yTitle }, grid: { display: true } }
      }
    };
  }

  function initCharts() {
    strideChart = new Chart(document.getElementById('strideChart'), {
      type: 'line',
      data: { labels: [], datasets: [{ label: 'Stride Length (cm) (LPF)', data: [] }] },
      options: baseChartOptions('Step #', 'cm')
    });

    stanceChart = new Chart(document.getElementById('stanceChart'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Stance Time (s) (LPF)', data: [] },
          { label: 'Swing Time (s) (LPF)', data: [] }
        ]
      },
      options: baseChartOptions('Step #', 'seconds')
    });

    kneeMSChart = new Chart(document.getElementById('kneeMSChart'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Knee Flexion Mid-Stance L (¬∞) (LPF)', data: [] },
          { label: 'Knee Flexion Mid-Stance R (¬∞) (LPF)', data: [] }
        ]
      },
      options: baseChartOptions('Step #', 'degrees')
    });

    grfCurveChart = new Chart(document.getElementById('grfCurveChart'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [{ label: 'GRF Proxy (BW) (smoothed)', data: [] }]
      },
      options: baseChartOptions('ms from IC', 'BW (proxy)')
    });
  }

  function numOrNull(v) {
    return (typeof v === 'number' && isFinite(v)) ? v : null;
  }

  function updateChartsFromSteps() {
    if (!strideChart || !stanceChart || !kneeMSChart) return;

    const steps = gait.steps;
    const maxPoints = 120;
    const start = Math.max(0, steps.length - maxPoints);
    const slice = steps.slice(start);
    const labels = slice.map(s => String(s.idx));

    // stride (EMA)
    const strideRaw = slice.map(s => numOrNull(s.strideCm));
    strideChart.data.labels = labels;
    strideChart.data.datasets[0].data = emaSeries(strideRaw, 0.28);
    strideChart.update('none');

    // stance/swing (EMA)
    const stanceRaw = slice.map(s => numOrNull(s.stanceTimeS));
    const swingRaw  = slice.map(s => numOrNull(s.swingTimeS));
    stanceChart.data.labels = labels;
    stanceChart.data.datasets[0].data = emaSeries(stanceRaw, 0.28);
    stanceChart.data.datasets[1].data = emaSeries(swingRaw, 0.28);
    stanceChart.update('none');

    // knee L/R (EMA)
    const kneeLRaw = slice.map(s => (s.side === 'L') ? numOrNull(s.kneeMidStanceDeg) : null);
    const kneeRRaw = slice.map(s => (s.side === 'R') ? numOrNull(s.kneeMidStanceDeg) : null);
    kneeMSChart.data.labels = labels;
    kneeMSChart.data.datasets[0].data = emaSeries(kneeLRaw, 0.30);
    kneeMSChart.data.datasets[1].data = emaSeries(kneeRRaw, 0.30);
    kneeMSChart.update('none');

    rebuildStepPicker();
  }

  function rebuildStepPicker() {
    if (!gait.steps.length) {
      stepPicker.innerHTML = '<option value="">(no steps yet)</option>';
      return;
    }
    const current = stepPicker.value;
    const opts = gait.steps.slice(-200).map(s => {
      const ttp = (typeof s.grfTimeToPeakMs === 'number') ? `${Math.round(s.grfTimeToPeakMs)}ms` : '‚Äî';
      const peak = (typeof s.grfPeakBW === 'number') ? s.grfPeakBW.toFixed(2) : '‚Äî';
      return `<option value="${s.idx}">#${s.idx} (${s.side}) peak ${peak}BW, TTP ${ttp}</option>`;
    }).join('');
    stepPicker.innerHTML = opts;

    if (current && gait.steps.some(s => String(s.idx) === current)) {
      stepPicker.value = current;
    } else {
      stepPicker.value = String(gait.steps[gait.steps.length - 1].idx);
    }
    renderSelectedGRFCurve();
  }

  function renderSelectedGRFCurve() {
    const v = stepPicker.value;
    if (!v || !grfCurveChart) return;
    const step = gait.steps.find(s => String(s.idx) === v);
    if (!step || !step.grfCurve || !step.grfCurve.length) {
      grfCurveChart.data.labels = [];
      grfCurveChart.data.datasets[0].data = [];
      grfCurveChart.update('none');
      return;
    }

    const labels = step.grfCurve.map(p => String(Math.round(p.tRelMs)));
    const bwRaw = step.grfCurve.map(p => p.bw);
    const bwSm = sma(bwRaw, 6);

    grfCurveChart.data.labels = labels;
    grfCurveChart.data.datasets[0].data = bwSm;
    grfCurveChart.update('none');
  }

  // ============================================================
  // UI helpers
  // ============================================================
  function viewMode() { return viewModeEl.value; }

  function setStatus(type, html) {
    statusDiv.className = 'status ' + type;
    statusDiv.innerHTML = html;
  }

  function syncModeUI() {
    const m = viewMode();
    modePill.textContent = m.toUpperCase();
    if (m === 'sagittal') {
      modePill.style.background = '#667eea';
      modeMetricLabel.textContent = 'Overstride Risk (last IC)';
      if (!modeMetricValue.textContent) modeMetricValue.textContent = 'Low';
    } else {
      modePill.style.background = '#e67e22';
      modeMetricLabel.textContent = 'Knee Medial Drift (proxy) - live';
      if (!modeMetricValue.textContent.includes('¬∞')) modeMetricValue.textContent = '0.0¬∞';
    }
  }

  function setSourceUI(mode) {
    sourceMode = mode;
    const label = mode.toUpperCase();
    sourcePill.textContent = label;
    sourcePill.style.background = (mode === 'camera') ? '#16a085' : (mode === 'video') ? '#f39c12' : '#2c3e50';
    sourceNote.textContent = (mode === 'camera')
      ? 'Source: camera stream'
      : (mode === 'video')
        ? 'Source: uploaded video file'
        : 'Source: none';

    videoControlsPanel.style.display = (mode === 'video') ? 'block' : 'none';
  }

  function setPhaseIndicator(phase) {
    for (let i = 1; i <= 4; i++) {
      const dot = document.getElementById('phase' + i);
      dot.classList.toggle('active', i === phase);
    }
  }

  function setRecordButtonUI() {
    recordBtn.classList.toggle('recording', isRecording);
    recordBtn.textContent = isRecording ? 'Stop Recording' : 'Start Recording';
  }

  // ============================================================
  // Reset state
  // ============================================================
  function resetGaitAll() {
    gait.feet.L = makeFootState('L');
    gait.feet.R = makeFootState('R');
    gait.steps = [];
    gait.icTimes = [];
    gait.vo = { baselineY: null, maxDevPx: 0, windowFrames: 0, lastVOcm: 0 };
    gait.lastVOcmLive = 0;
    detectedIssues = new Set();

    document.getElementById('issuesList').innerHTML =
      '<div style="text-align:center; color:#999; padding:18px;">No issues detected yet</div>';

    document.getElementById('cadence').innerHTML = `0<span class="metric-unit">steps/min</span>`;
    document.getElementById('stanceTime').innerHTML = `0<span class="metric-unit">s</span>`;
    document.getElementById('swingTime').innerHTML = `0<span class="metric-unit">s</span>`;
    document.getElementById('strideLength').innerHTML = `0<span class="metric-unit">cm</span>`;
    document.getElementById('kneeMSL').innerHTML = `0<span class="metric-unit">¬∞</span>`;
    document.getElementById('kneeMSR').innerHTML = `0<span class="metric-unit">¬∞</span>`;
    document.getElementById('pelvicTilt').innerHTML = `0<span class="metric-unit">¬∞</span>`;
    document.getElementById('vertOsc').innerHTML = `0<span class="metric-unit">cm</span>`;
    document.getElementById('grfPeak').innerHTML = `0<span class="metric-unit">BW</span>`;
    document.getElementById('grfTTP').innerHTML = `0<span class="metric-unit">ms</span>`;
    document.getElementById('gaitPhase').textContent = 'Standing';
    setPhaseIndicator(1);

    exportBtn.disabled = true;

    if (strideChart) { strideChart.data.labels = []; strideChart.data.datasets[0].data = []; strideChart.update('none'); }
    if (stanceChart) {
      stanceChart.data.labels = [];
      stanceChart.data.datasets[0].data = [];
      stanceChart.data.datasets[1].data = [];
      stanceChart.update('none');
    }
    if (kneeMSChart) {
      kneeMSChart.data.labels = [];
      kneeMSChart.data.datasets[0].data = [];
      kneeMSChart.data.datasets[1].data = [];
      kneeMSChart.update('none');
    }
    if (grfCurveChart) { grfCurveChart.data.labels = []; grfCurveChart.data.datasets[0].data = []; grfCurveChart.update('none'); }
    rebuildStepPicker();
  }

  // ============================================================
  // TF backend init
  // ============================================================
  async function initTFBackend() {
    await tf.ready();
    const preferred = (isIOS || isSafari) ? ['webgl', 'cpu'] : ['webgpu', 'webgl', 'cpu'];
    let ok = false;
    for (const b of preferred) {
      try {
        await tf.setBackend(b);
        await tf.ready();
        ok = true;
        break;
      } catch (_) {}
    }
    if (!ok) throw new Error('No TFJS backend could be initialized.');
    return tf.getBackend();
  }

  async function initModel() {
    setStatus('loading', '<span class="loading-spinner"></span> Loading TensorFlow backend‚Ä¶');
    const backend = await initTFBackend();

    setStatus('loading', `<span class="loading-spinner"></span> Loading MoveNet (backend: ${backend})‚Ä¶`);
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {
        modelType: (isIOS || isSafari)
          ? poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
          : poseDetection.movenet.modelType.SINGLEPOSE_THUNDER,
        enableTracking: true,
        trackerType: poseDetection.TrackerType.BoundingBox
      }
    );

    initCharts();
    syncModeUI();
    setSourceUI('none');
    setStatus('ready', `‚úì Model Ready (backend: ${backend}) ‚Äî Choose Camera or Upload Video`);
    startCamBtn.disabled = false;
    loadVideoBtn.disabled = false;
  }

  // ============================================================
  // Media cleanup
  // ============================================================
  function stopLoops() {
    isRunning = false;
    if (animId) cancelAnimationFrame(animId);
    animId = null;
    vfcActive = false;
  }

  function stopStream() {
    if (mediaStream) {
      mediaStream.getTracks().forEach(t => t.stop());
      mediaStream = null;
    }
  }

  function revokeVideoUrl() {
    if (videoObjectUrl) {
      URL.revokeObjectURL(videoObjectUrl);
      videoObjectUrl = null;
    }
  }

  function clearVideoSource() {
    try { webcam.pause(); } catch (_) {}
    webcam.removeAttribute('src');
    webcam.srcObject = null;
    webcam.load();
  }

  function stopAll() {
    // IMPORTANT: if recording, stop cleanly without flipping twice
    if (isRecording) stopRecording();

    stopLoops();
    stopStream();
    revokeVideoUrl();
    clearVideoSource();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    fpsDisplay.textContent = 'FPS: 0';

    setSourceUI('none');

    playPauseBtn.disabled = true;
    stopBtn.disabled = true;
    recordBtn.disabled = true;
    exportBtn.disabled = true;
    snapshotBtn.disabled = true;

    stepBackBtn.disabled = true;
    stepFwdBtn.disabled = true;
    skipBackBtn.disabled = true;
    skipFwdBtn.disabled = true;

    setStatus('ready', 'Stopped. Choose Camera or Upload Video.');
  }

  // ============================================================
  // Camera start
  // ============================================================
  async function startCamera() {
    try {
      stopAll();
      resetGaitAll();

      setStatus('loading', '<span class="loading-spinner"></span> Starting camera‚Ä¶');
      setSourceUI('camera');

      webcam.muted = true;
      webcam.playsInline = true;
      webcam.setAttribute('playsinline', '');
      webcam.setAttribute('muted', '');

      const tryConstraints = [
        { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 120, max: 120 } } },
        { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 },  frameRate: { ideal: 60,  max: 60  } } },
        { video: { facingMode: { ideal: 'environment' } } }
      ];

      let stream = null, lastErr = null;
      for (const c of tryConstraints) {
        try { stream = await navigator.mediaDevices.getUserMedia(c); break; }
        catch (e) { lastErr = e; }
      }
      if (!stream) throw lastErr || new Error('Unable to access camera');

      mediaStream = stream;
      webcam.srcObject = stream;

      await new Promise(res => webcam.onloadeddata = () => res());
      await webcam.play();

      canvas.width = webcam.videoWidth || 640;
      canvas.height = webcam.videoHeight || 480;

      const track = stream.getVideoTracks()[0];
      const settings = track.getSettings ? track.getSettings() : {};
      const gotFps = settings.frameRate ? Math.round(settings.frameRate) : null;

      stopBtn.disabled = false;
      recordBtn.disabled = false;
      snapshotBtn.disabled = false;
      playPauseBtn.disabled = true;

      // Recording state should start OFF
      isRecording = false;
      setRecordButtonUI();

      setStatus('ready', gotFps && gotFps < 90
        ? `‚ö†Ô∏è Camera delivered ~${gotFps} fps. Analysis works; GRF timing is less crisp than true 120fps.`
        : 'üé• Camera active. Ready.');

      isRunning = true;
      loopFrames = 0;
      loopFpsT0 = performance.now();
      loopPose(performance.now());
    } catch (e) {
      setSourceUI('none');
      setStatus('error', '‚úó Camera Error: ' + (e?.message || e));
      console.error(e);
    }
  }

  // ============================================================
  // Video upload
  // ============================================================
  async function loadVideoFile(file) {
    try {
      stopAll();
      resetGaitAll();

      setSourceUI('video');
      setStatus('loading', '<span class="loading-spinner"></span> Loading video‚Ä¶');

      revokeVideoUrl();
      videoObjectUrl = URL.createObjectURL(file);

      webcam.muted = true;
      webcam.playsInline = true;
      webcam.setAttribute('playsinline', '');
      webcam.setAttribute('muted', '');

      webcam.src = videoObjectUrl;
      webcam.load();

      await new Promise((res, rej) => {
        const onLoaded = () => res();
        const onErr = () => rej(new Error('Failed to load video'));
        webcam.addEventListener('loadeddata', onLoaded, { once: true });
        webcam.addEventListener('error', onErr, { once: true });
      });

      canvas.width = webcam.videoWidth || 640;
      canvas.height = webcam.videoHeight || 480;

      stopBtn.disabled = false;
      recordBtn.disabled = false;
      snapshotBtn.disabled = false;
      playPauseBtn.disabled = false;

      stepBackBtn.disabled = false;
      stepFwdBtn.disabled = false;
      skipBackBtn.disabled = false;
      skipFwdBtn.disabled = false;

      playPauseBtn.textContent = 'Play';

      // Recording state should start OFF
      isRecording = false;
      setRecordButtonUI();

      updateSeekUI();
      videoMetaLabel.textContent = `Video: ${webcam.videoWidth}x${webcam.videoHeight}, duration ${formatTime(webcam.duration)} (s), VFC: ${useVFC ? 'yes' : 'no'}`;

      setStatus('ready', 'üìº Video loaded. Press Play, or scrub using the seek bar / frame-step.');
      isRunning = false;
      fpsDisplay.textContent = 'FPS: 0';
    } catch (e) {
      setSourceUI('none');
      setStatus('error', '‚úó Video Error: ' + (e?.message || e));
      console.error(e);
    }
  }

  async function togglePlayPause() {
    if (sourceMode !== 'video') return;
    if (!webcam.src) return;

    if (webcam.paused) {
      await webcam.play();
      playPauseBtn.textContent = 'Pause';
      startVideoAnalysisLoop();
    } else {
      webcam.pause();
      playPauseBtn.textContent = 'Play';
      stopLoops();
    }
  }

  function startVideoAnalysisLoop() {
    stopLoops();
    isRunning = true;
    loopFrames = 0;
    loopFpsT0 = performance.now();

    if (useVFC) {
      vfcActive = true;
      const cb = (now, metadata) => {
        if (!vfcActive || !isRunning || webcam.paused || webcam.ended) return;
        const tMs = (metadata && typeof metadata.mediaTime === 'number')
          ? metadata.mediaTime * 1000
          : (webcam.currentTime * 1000);
        loopPose(tMs);
        webcam.requestVideoFrameCallback(cb);
      };
      webcam.requestVideoFrameCallback(cb);
    } else {
      const raf = () => {
        if (!isRunning || webcam.paused || webcam.ended) return;
        loopPose(webcam.currentTime * 1000);
        animId = requestAnimationFrame(raf);
      };
      animId = requestAnimationFrame(raf);
    }
  }

  // ============================================================
  // Loop + pose
  // ============================================================
  async function loopPose(tNowMs) {
    if (!isRunning) return;

    loopFrames++;
    const nowPerf = performance.now();
    if ((nowPerf - loopFpsT0) >= 1000) {
      const loopFps = Math.round(loopFrames * 1000 / (nowPerf - loopFpsT0));
      fpsDisplay.textContent = `FPS: ${loopFps}` + (sourceMode === 'video' ? ' (analysis)' : '');
      loopFrames = 0;
      loopFpsT0 = nowPerf;
    }

    try {
      const poses = await detector.estimatePoses(webcam);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (poses && poses.length > 0 && poses[0]?.keypoints?.length) {
        const kps = poses[0].keypoints;
        drawSkeleton(kps);
        analyzePerFrame(kps, tNowMs);
      }
    } catch (e) {
      console.error('Pose error:', e);
    }

    if (sourceMode === 'camera') {
      animId = requestAnimationFrame(() => loopPose(performance.now()));
    }
  }

  // ============================================================
  // Drawing
  // ============================================================
  function drawSkeleton(keypoints) {
    const conns = [
      { a: 5, b: 7, c: '#3498db' }, { a: 7, b: 9, c: '#3498db' },
      { a: 5, b: 11, c: '#3498db' }, { a: 11, b: 13, c: '#3498db' }, { a: 13, b: 15, c: '#3498db' },
      { a: 6, b: 8, c: '#2ecc71' }, { a: 8, b: 10, c: '#2ecc71' },
      { a: 6, b: 12, c: '#2ecc71' }, { a: 12, b: 14, c: '#2ecc71' }, { a: 14, b: 16, c: '#2ecc71' },
      { a: 5, b: 6, c: '#9b59b6' }, { a: 11, b: 12, c: '#9b59b6' }
    ];

    ctx.lineWidth = 5;
    for (const conn of conns) {
      const p1 = keypoints[conn.a], p2 = keypoints[conn.b];
      if (p1?.score > 0.3 && p2?.score > 0.3) {
        ctx.strokeStyle = conn.c;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    }

    for (let i = 0; i < keypoints.length; i++) {
      const kp = keypoints[i];
      if (kp?.score > 0.3) {
        ctx.beginPath();
        ctx.arc(kp.x, kp.y, 8, 0, 2*Math.PI);
        if ([5,7,9,11,13,15].includes(i)) ctx.fillStyle = '#3498db';
        else if ([6,8,10,12,14,16].includes(i)) ctx.fillStyle = '#2ecc71';
        else ctx.fillStyle = '#9b59b6';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }

  // ============================================================
  // Analysis
  // ============================================================
  function analyzePerFrame(kps, tNowMs) {
    const subject = {
      sex: subjectSexEl.value,
      age: parseFloat(subjectAgeEl.value || '0'),
      mass: parseFloat(subjectMassEl.value || '0'),
      height: parseFloat(subjectHeightEl.value || '0')
    };
    const th = TH[subject.sex] || TH.male;

    const m = viewMode();

    const get = (i) => (kps[i] && kps[i].score > 0.3) ? kps[i] : null;

    const nose = get(0);
    const hipL = get(11), hipR = get(12);
    const kneeL = get(13), kneeR = get(14);
    const ankleL = get(15), ankleR = get(16);

    if (!ankleL && !ankleR) return;

    // Height-based spatial calibration
    const pxToCm = estimatePxToCm(nose, ankleL, ankleR, subject.height);

    // Pelvic tilt
    const pelvicTiltDeg = computePelvicTiltDeg(hipL, hipR);
    document.getElementById('pelvicTilt').innerHTML = `${pelvicTiltDeg.toFixed(1)}<span class="metric-unit">¬∞</span>`;
    if (pelvicTiltDeg >= th.pelvicTiltCrit) addIssueTagged('collapser', 'critical', `COLLAPSER: excessive lateral pelvic tilt (${pelvicTiltDeg.toFixed(1)}¬∞)`);
    else if (pelvicTiltDeg >= th.pelvicTiltWarn) addIssueTagged('collapser', 'warning', `COLLAPSER: elevated lateral pelvic tilt (${pelvicTiltDeg.toFixed(1)}¬∞)`);

    // VO (cm)
    const hipMidY = midY(hipL, hipR);
    if (hipMidY != null && pxToCm) {
      const voCm = updateVerticalOscillation(hipMidY, pxToCm);
      gait.lastVOcmLive = voCm;
      document.getElementById('vertOsc').innerHTML = `${voCm.toFixed(1)}<span class="metric-unit">cm</span>`;
      if (voCm >= th.voCritCm) addIssueTagged('bouncer', 'critical', `BOUNCER: excessive vertical oscillation (${voCm.toFixed(1)}cm)`);
      else if (voCm >= th.voWarnCm) addIssueTagged('bouncer', 'warning', `BOUNCER: high vertical oscillation (${voCm.toFixed(1)}cm)`);
    }

    // knee angles
    const kneeDegL = (hipL && kneeL && ankleL) ? calculateAngle(hipL, kneeL, ankleL) : null;
    const kneeDegR = (hipR && kneeR && ankleR) ? calculateAngle(hipR, kneeR, ankleR) : null;

    // Frontal knee drift proxy (live)
    if (m === 'frontal') {
      const drift = computeKneeMedialDriftProxyDeg(hipL, kneeL, ankleL, hipR, kneeR, ankleR);
      modeMetricValue.textContent = `${drift.toFixed(1)}¬∞`;
    }

    // feet (IC/TO handled per side)
    handleFoot('L', tNowMs, ankleL, hipL, hipR, kneeDegL, pelvicTiltDeg, pxToCm, m, th);
    handleFoot('R', tNowMs, ankleR, hipL, hipR, kneeDegR, pelvicTiltDeg, pxToCm, m, th);

    updatePhaseUI(gait.feet.L.contact, gait.feet.R.contact);
    updateCadenceUI();
    updateRollingUI();

    exportBtn.disabled = gait.steps.length === 0;
  }

  function handleFoot(side, tNow, ankle, hipL, hipR, kneeDeg, pelvicTiltDeg, pxToCm, mode, th) {
    const f = gait.feet[side];
    if (!ankle) return;

    // ground baseline follows slowly to max y
    const alpha = 0.05;
    if (f.groundY == null) f.groundY = ankle.y;
    f.groundY = (1 - alpha) * f.groundY + alpha * Math.max(f.groundY, ankle.y);

    // hysteresis for contact
    const thrOn = 18, thrOff = 26;
    const dist = f.groundY - ankle.y;

    let contactNow = f.contact;
    if (!f.contact && dist < thrOn) contactNow = true;
    if (f.contact && dist > thrOff) contactNow = false;

    // v & a
    const dt = Math.max(1e-3, (tNow - f.prev.t) / 1000);
    const vY = (f.prev.ok) ? (ankle.y - f.prev.y) / dt : 0;
    const aY = (dt > 0) ? (vY - (f.prevVY || 0)) / dt : 0;
    f.prevVY = vY;

    const ic = (!f.contact && contactNow && vY > -400);
    const to = (f.contact && !contactNow);

    if (ic) onInitialContact(side, tNow, ankle, hipL, hipR, pxToCm, mode, th);
    if (f.active && f.active.inStance) {
      if (typeof kneeDeg === 'number') f.active.samples.push({ t: tNow, kneeDeg });

      f.active.pelvicTiltMaxDeg = Math.max(f.active.pelvicTiltMaxDeg, pelvicTiltDeg);

      // GRF curve throughout stance (downsample)
      const decel = Math.max(0, -aY);
      const bw = mapDecelProxyToBW(decel);
      const tRelMs = tNow - f.active.tIC_ms;

      if ((f.active.grfCurve.length === 0) || (tRelMs - f.active.grfCurve[f.active.grfCurve.length - 1].tRelMs >= 8)) {
        f.active.grfCurve.push({ tRelMs, bw });
      }

      const earlyWindowMs = 140;
      if (tRelMs <= earlyWindowMs) {
        if (decel > f.active.grfProxy.peak) {
          f.active.grfProxy.peak = decel;
          f.active.grfProxy.tPeak = tNow;
        }
      }
    }

    if (to) onToeOff(side, tNow);

    f.contact = contactNow;
    f.prev = { t: tNow, x: ankle.x, y: ankle.y, ok: true };
  }

  function onInitialContact(side, tIC, ankle, hipL, hipR, pxToCm, mode, th) {
    if (!isRecording) return;

    const f = gait.feet[side];

    // debounce
    const minICGapMs = 220;
    if (f.lastIC && (tIC - f.lastIC) < minICGapMs) return;

    const hipMidX = midX(hipL, hipR);

    // fill swing time for last same-side step (TO -> this IC)
    const lastSame = findLastStepOfSide(side);
    if (lastSame && typeof lastSame.tTO_ms === 'number' && typeof lastSame.swingTimeS !== 'number') {
      lastSame.swingTimeS = (tIC - lastSame.tTO_ms) / 1000;
    }

    // stride proxy from hip mid X between same-side ICs (calibrated by height)
    if (pxToCm && f.lastIC_hipX != null && hipMidX != null) {
      const strideCm = Math.abs(hipMidX - f.lastIC_hipX) * pxToCm;
      if (lastSame && typeof lastSame.strideCm !== 'number') lastSame.strideCm = strideCm;
    }

    // start active step
    f.active = {
      side,
      tIC_ms: tIC,
      tTO_ms: null,
      inStance: true,
      stanceTimeS: null,
      swingTimeS: null,
      strideCm: null,
      kneeMidStanceDeg: null,
      pelvicTiltMaxDeg: 0,
      samples: [],
      grfProxy: { peak: 0, tPeak: null },
      grfCurve: [],
      overstrideLevel: null,
      landingQuality: null,
      grfPeakBW: null,
      grfTimeToPeakMs: null,
      notes: ''
    };

    // Sagittal: overstride tag
    if (mode === 'sagittal') {
      const over = computeOverstrideRisk(hipMidX, ankle, canvas.height || 1, th);
      f.active.overstrideLevel = over.level;
      modeMetricValue.textContent = over.level;

      if (over.level === 'High') {
        addIssueTagged('overstrider', 'critical', `${side}: OVERSTRIDER ‚Äî overstriding at IC`);
        f.active.notes += 'Overstriding at IC (high); ';
      } else if (over.level === 'Moderate') {
        addIssueTagged('overstrider', 'warning', `${side}: OVERSTRIDER ‚Äî moderate overstride at IC`);
        f.active.notes += 'Overstriding at IC (moderate); ';
      }
    }

    // Frontal: crossover gait at IC (sex-specific, hip-width normalized)
    if (mode === 'frontal') {
      const crossover = detectCrossoverAtIC(side, ankle, hipL, hipR, th);
      if (crossover) {
        if (crossover.level === 'Critical') {
          addIssueTagged('crosser', 'critical', `${side}: CROSSER ‚Äî crossover gait (foot crosses midline at IC)`);
          f.active.notes += 'Crossover gait at IC (critical); ';
        } else {
          addIssueTagged('crosser', 'warning', `${side}: CROSSER ‚Äî crossover gait tendency (crosses midline at IC)`);
          f.active.notes += 'Crossover gait at IC (warning); ';
        }
      }
    }

    gait.icTimes.push(tIC);
    if (gait.icTimes.length > 12) gait.icTimes.shift();

    f.lastIC = tIC;
    f.lastIC_hipX = (hipMidX != null) ? hipMidX : null;

    setPhaseIndicator(1);
  }

  function onToeOff(side, tTO) {
    if (!isRecording) return;

    const f = gait.feet[side];
    if (!f.active || !f.active.inStance) return;

    f.active.tTO_ms = tTO;
    f.active.inStance = false;
    f.active.stanceTimeS = (tTO - f.active.tIC_ms) / 1000;

    f.active.kneeMidStanceDeg = computeKneeMidStance(f.active.samples, f.active.tIC_ms, tTO);

    const tPeak = f.active.grfProxy.tPeak;
    const ttpMs = (tPeak != null) ? Math.max(0, tPeak - f.active.tIC_ms) : null;
    f.active.grfTimeToPeakMs = ttpMs;

    const grfBW = mapDecelProxyToBW(f.active.grfProxy.peak);
    f.active.grfPeakBW = grfBW;
    f.active.landingQuality = classifyLanding(grfBW, ttpMs);

    // Step-level notes/issues (keep simple and readable)
    if (typeof f.active.kneeMidStanceDeg === 'number' && f.active.kneeMidStanceDeg > 165) {
      addIssueTagged('generic', 'warning', `${side}: Low mid-stance knee flexion`);
      f.active.notes += 'Low mid-stance knee flexion; ';
    }
    if (f.active.landingQuality === 'Hard') {
      addIssueTagged('generic', 'warning', `${side}: Hard landing tendency (GRF proxy)`);
      f.active.notes += 'Hard landing tendency; ';
    }

    updateLastStepCards(f.active);
    finalizeStep(f.active);

    f.active = null;
    f.lastTO = tTO;

    setPhaseIndicator(3);
  }

  function computeKneeMidStance(samples, tIC, tTO) {
    if (!samples || !samples.length) return null;
    const target = tIC + 0.5 * (tTO - tIC);
    let best = null, bestDt = Infinity;
    for (const s of samples) {
      const dt = Math.abs(s.t - target);
      if (dt < bestDt) { bestDt = dt; best = s.kneeDeg; }
    }
    return (typeof best === 'number') ? best : null;
  }

  function updateLastStepCards(step) {
    if (step.side === 'L') {
      document.getElementById('kneeMSL').innerHTML = `${(step.kneeMidStanceDeg ?? 0).toFixed(0)}<span class="metric-unit">¬∞</span>`;
    } else {
      document.getElementById('kneeMSR').innerHTML = `${(step.kneeMidStanceDeg ?? 0).toFixed(0)}<span class="metric-unit">¬∞</span>`;
    }
    document.getElementById('grfPeak').innerHTML = `${(step.grfPeakBW ?? 0).toFixed(2)}<span class="metric-unit">BW</span>`;
    document.getElementById('grfTTP').innerHTML = `${(step.grfTimeToPeakMs ?? 0).toFixed(0)}<span class="metric-unit">ms</span>`;
  }

  function finalizeStep(step) {
    const row = {
      idx: gait.steps.length + 1,
      side: step.side,
      tIC_ms: step.tIC_ms,
      tTO_ms: step.tTO_ms,
      stanceTimeS: step.stanceTimeS,
      swingTimeS: step.swingTimeS,
      strideCm: step.strideCm,
      kneeMidStanceDeg: step.kneeMidStanceDeg,
      pelvicTiltMaxDeg: step.pelvicTiltMaxDeg,
      grfPeakBW: step.grfPeakBW,
      grfTimeToPeakMs: step.grfTimeToPeakMs,
      landingQuality: step.landingQuality,
      overstrideLevel: step.overstrideLevel,
      grfCurve: step.grfCurve || [],
      notes: (step.notes || '').trim()
    };
    gait.steps.push(row);

    // Update charts every step (fix "charts missing" perception)
    updateChartsFromSteps();

    stepPicker.value = String(row.idx);
    renderSelectedGRFCurve();
  }

  function findLastStepOfSide(side) {
    for (let i = gait.steps.length - 1; i >= 0; i--) {
      if (gait.steps[i].side === side) return gait.steps[i];
    }
    return null;
  }

  // ============================================================
  // Phase + cadence + rolling stats
  // ============================================================
  function updatePhaseUI(L_contact, R_contact) {
    let label = 'Standing', dot = 1;
    if (L_contact && R_contact) { label = 'Double Support'; dot = 2; }
    else if (L_contact && !R_contact) { label = 'Right Swing'; dot = 4; }
    else if (!L_contact && R_contact) { label = 'Left Swing'; dot = 4; }
    else if (!L_contact && !R_contact) { label = 'Flight / Both Swing'; dot = 4; }
    document.getElementById('gaitPhase').textContent = label;
    setPhaseIndicator(dot);
  }

  function updateCadenceUI() {
    const t = gait.icTimes;
    if (t.length < 4) return;
    const slice = t.slice(-8);

    const deltas = [];
    for (let i = 1; i < slice.length; i++) deltas.push((slice[i] - slice[i-1]) / 1000);
    const avg = deltas.reduce((a,b)=>a+b,0) / deltas.length;
    const cadence = avg > 0 ? Math.round(60 / avg) : 0;

    document.getElementById('cadence').innerHTML = `${cadence}<span class="metric-unit">steps/min</span>`;
    if (cadence > 0 && cadence < 160) addIssueTagged('generic', 'warning', 'Low cadence - consider increasing step rate');
  }

  function updateRollingUI() {
    const steps = gait.steps;
    if (!steps.length) return;
    const n = gait.recentWindow;
    const slice = steps.slice(-n);

    const nums = (k) => slice.map(s => s[k]).filter(v => typeof v === 'number' && isFinite(v));
    const mean = (arr) => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;

    const stanceAvg = mean(nums('stanceTimeS'));
    const swingAvg = mean(nums('swingTimeS'));
    const strideAvg = mean(nums('strideCm'));

    document.getElementById('stanceTime').innerHTML = `${stanceAvg.toFixed(2)}<span class="metric-unit">s</span>`;
    document.getElementById('swingTime').innerHTML = `${swingAvg.toFixed(2)}<span class="metric-unit">s</span>`;
    document.getElementById('strideLength').innerHTML = `${strideAvg.toFixed(0)}<span class="metric-unit">cm</span>`;
  }

  // ============================================================
  // VO + Pelvic + Frontal drift
  // ============================================================
  function updateVerticalOscillation(hipMidY, pxToCm) {
    const vo = gait.vo;
    const alpha = 0.02;
    if (vo.baselineY == null) vo.baselineY = hipMidY;
    vo.baselineY = (1 - alpha) * vo.baselineY + alpha * hipMidY;

    const devPx = Math.abs(hipMidY - vo.baselineY);
    vo.maxDevPx = Math.max(vo.maxDevPx, devPx);
    vo.windowFrames++;

    if (vo.windowFrames >= 30) {
      vo.lastVOcm = vo.maxDevPx * pxToCm;
      vo.maxDevPx = 0;
      vo.windowFrames = 0;
    }
    return vo.lastVOcm;
  }

  function computePelvicTiltDeg(hipL, hipR) {
    if (!hipL || !hipR) return 0;
    const dy = (hipR.y - hipL.y);
    const dx = (hipR.x - hipL.x) || 1;
    return Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);
  }

  function computeKneeMedialDriftProxyDeg(hipL, kneeL, ankleL, hipR, kneeR, ankleR) {
    const ang = (hip, knee, ankle) => {
      if (!hip || !knee || !ankle) return null;
      const ax = (hip.x - knee.x) * 1.5, ay = (hip.y - knee.y);
      const bx = (ankle.x - knee.x) * 1.5, by = (ankle.y - knee.y);
      const dot = ax*bx + ay*by;
      const na = Math.hypot(ax, ay) || 1;
      const nb = Math.hypot(bx, by) || 1;
      const cos = Math.max(-1, Math.min(1, dot/(na*nb)));
      return Math.acos(cos) * 180 / Math.PI;
    };

    const aL = ang(hipL, kneeL, ankleL);
    const aR = ang(hipR, kneeR, ankleR);

    const driftL = (aL != null) ? Math.max(0, 180 - aL) : null;
    const driftR = (aR != null) ? Math.max(0, 180 - aR) : null;

    const vals = [driftL, driftR].filter(v => typeof v === 'number');
    const max = vals.length ? Math.max(...vals) : 0;

    if (max > 18) addIssueTagged('generic', 'critical', 'Frontal: High knee medial drift (valgus proxy)');
    else if (max > 12) addIssueTagged('generic', 'warning', 'Frontal: Moderate knee medial drift (valgus proxy)');

    return max;
  }

  // ============================================================
  // Crossover gait (frontal, IC) - sex-specific
  // ============================================================
  function detectCrossoverAtIC(side, ankle, hipL, hipR, th) {
    if (!ankle || !hipL || !hipR) return null;

    const midlineX = (hipL.x + hipR.x) / 2;
    const hipW = Math.abs(hipR.x - hipL.x);
    if (!isFinite(hipW) || hipW < 10) return null;

    const dx = ankle.x - midlineX;
    const wrongSide = (side === 'L') ? (dx > 0) : (dx < 0);
    if (!wrongSide) return null;

    const mag = Math.abs(dx);
    const warn = th.crossoverWarnHipW * hipW;
    const crit = th.crossoverCritHipW * hipW;

    if (mag >= crit) return { level: 'Critical', magPx: mag, hipW };
    if (mag >= warn) return { level: 'Warning', magPx: mag, hipW };
    return null;
  }

  // ============================================================
  // GRF proxy
  // ============================================================
  function mapDecelProxyToBW(p) {
    const x = Math.max(0, Math.min(p, 20000));
    return 1.2 + 1.8 * (1 - Math.exp(-x / 6000)); // asymptote ~3.0
  }

  function classifyLanding(grfBW, ttpMs) {
    if (ttpMs == null) return 'Moderate';
    if (grfBW >= 2.6 && ttpMs <= 70) return 'Hard';
    if (grfBW <= 2.0 && ttpMs >= 110) return 'Soft';
    return 'Moderate';
  }

  // ============================================================
  // Geometry helpers
  // ============================================================
  function estimatePxToCm(nose, ankleL, ankleR, heightCm) {
    if (!heightCm || !nose || (!ankleL && !ankleR)) return null;
    const lowestAnkleY = Math.max(ankleL ? ankleL.y : 0, ankleR ? ankleR.y : 0);
    const bodyPx = Math.abs(lowestAnkleY - nose.y);
    if (bodyPx < 50) return null;
    return heightCm / bodyPx;
  }

  function midX(a, b) {
    if (a && b) return (a.x + b.x) / 2;
    if (a) return a.x;
    if (b) return b.x;
    return null;
 
