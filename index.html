<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gait Biodynamics Lab - Camera + High-FPS Video Upload</title>
  <meta name="description" content="Step-based running gait analysis with MoveNet. Supports camera and high-FPS video upload, XLSX export, PNG snapshot, seek + frame-step, and GRF-time proxy curves.">

  <!--
    Gait Biodynamics Lab
    Copyright (c) 2025 Ng Jun Wei. All rights reserved.
    Unauthorized copying, modification, distribution, or use of this software, via any medium, is strictly prohibited.
  -->

  <!-- TFJS + Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 { text-align:center; color:#667eea; margin-bottom:10px; font-size:2.35em; }
    .subtitle { text-align:center; color:#666; margin-bottom:16px; }

    .status { padding:10px; border-radius:8px; margin-bottom:16px; text-align:center; font-weight:650; }
    .status.loading { background:#fff3cd; color:#856404; }
    .status.ready { background:#d4edda; color:#155724; }
    .status.error { background:#f8d7da; color:#721c24; }

    .loading-spinner {
      display:inline-block;
      width:18px; height:18px;
      border:3px solid rgba(102,126,234,0.25);
      border-radius:50%;
      border-top-color:#667eea;
      animation:spin 1s linear infinite;
      vertical-align:-3px;
      margin-right:8px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .info-section { padding:16px; background:#f8f9fa; border-radius:14px; }
    .info-section h3 { color:#667eea; margin-bottom:10px; }
    .grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap:12px; }
    label { display:block; margin-bottom:6px; font-weight:650; color:#666; }
    select, input[type="number"] {
      width:100%;
      padding:10px;
      border:2px solid #667eea;
      border-radius:8px;
      font-size:14px;
      outline:none;
    }
    .hint { margin-top:8px; font-size:12px; color:#666; line-height:1.35; }

    .main-content {
      display:grid;
      grid-template-columns: 2fr 1fr;
      gap: 22px;
      margin-top: 14px;
    }
    @media (max-width: 968px) {
      .main-content { grid-template-columns: 1fr; }
      h1 { font-size: 1.8em; }
    }

    .video-section { position:relative; }
    #videoContainer {
      position:relative;
      width:100%;
      background:#000;
      border-radius:15px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #webcam { width:100%; display:block; background:#000; }
    #canvas {
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
    }
    .fps-indicator {
      position:absolute;
      top:10px; right:10px;
      background: rgba(0,0,0,0.7);
      color:#0f0;
      padding:8px 12px;
      border-radius:8px;
      font-weight:700;
      font-size:13px;
      z-index:10;
    }

    .controls { display:flex; gap:10px; margin-top:14px; flex-wrap:wrap; }
    button {
      flex:1;
      min-width:170px;
      padding: 12px 14px;
      font-size: 14px;
      font-weight: 800;
      border:none;
      border-radius:10px;
      cursor:pointer;
      transition: transform 0.15s ease, opacity 0.15s ease;
      text-transform: uppercase;
      letter-spacing: 0.7px;
    }
    button:disabled { opacity:0.55; cursor:not-allowed; }
    button:hover:not(:disabled) { transform: translateY(-1px); }

    #startCamBtn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; }
    #loadVideoBtn { background: #f39c12; color:#1f1f1f; }
    #playPauseBtn { background: #2c3e50; color:white; }
    #stopBtn { background: #e74c3c; color:white; }
    #recordBtn { background: #27ae60; color:white; }
    #recordBtn.recording { background:#e74c3c; animation:pulse 1.5s infinite; }
    #exportBtn { background: #3498db; color:white; }
    #snapshotBtn { background: #8e44ad; color:white; }
    @keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.7; } }

    .analysis-panel {
      background:#f8f9fa;
      border-radius:15px;
      padding:16px;
      height: fit-content;
    }
    .pill {
      display:inline-block;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:900;
      color:white;
      background:#667eea;
      margin-left:8px;
    }

    .gait-phase {
      background:white;
      padding:14px;
      border-radius:12px;
      margin-bottom:12px;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }
    .metric-label { font-size:12px; color:#666; text-transform:uppercase; letter-spacing:1px; margin-bottom:5px; }
    .metric-value { font-size:18px; font-weight:900; color:#222; }
    .metric-unit { font-size:13px; color:#999; margin-left:6px; font-weight:700; }

    .phase-indicator { display:flex; justify-content:space-between; margin-top:10px; }
    .phase-dot {
      width:40px; height:40px;
      border-radius:50%;
      background:#e0e0e0;
      display:flex; align-items:center; justify-content:center;
      font-size:10px; font-weight:900; color:#999;
      transition: all 0.25s ease;
    }
    .phase-dot.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color:white;
      transform: scale(1.14);
    }

    .metrics { display:grid; gap:10px; margin-top:10px; }
    .metric-card {
      background:white;
      padding:12px;
      border-radius:12px;
      border-left:4px solid #667eea;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }

    .issues-list {
      background:white;
      padding:12px;
      border-radius:12px;
      max-height: 210px;
      overflow-y:auto;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }
    .issue-item { padding:9px; margin-bottom:8px; border-radius:7px; font-size:13px; }
    .issue-item.warning { background:#fff3cd; border-left:3px solid #ffc107; }
    .issue-item.critical { background:#f8d7da; border-left:3px solid #dc3545; }
    .issue-tag {
      display:inline-block;
      font-size:11px;
      font-weight:900;
      padding:3px 8px;
      border-radius:999px;
      margin-left:8px;
      background:#2c3e50;
      color:#fff;
      vertical-align:1px;
    }

    .charts-section {
      margin-top:18px;
      padding:16px;
      background:#f8f9fa;
      border-radius:15px;
    }
    .charts-section h3 { color:#667eea; margin-bottom:12px; }
    .chart-container {
      background:white;
      padding:14px;
      border-radius:12px;
      margin-bottom:12px;
      box-shadow:0 2px 10px rgba(0,0,0,0.08);
    }
    .chart-container canvas { max-height: 320px; }

    .tiny { font-size:12px; color:#666; margin-top:10px; line-height:1.35; }
    .row-note { margin-top:8px; font-size:12px; color:#666; }

    /* Video controls panel */
    .video-controls {
      margin-top: 12px;
      background: #f8f9fa;
      border-radius: 12px;
      padding: 12px;
      display: none;
    }
    .vc-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .seek-row {
      display: grid;
      grid-template-columns: 90px 1fr 140px;
      gap: 10px;
      align-items: center;
    }
    input[type="range"] { width: 100%; }
    .vc-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .vc-buttons button {
      min-width: 140px;
      flex: 1;
      padding: 10px 12px;
      font-size: 13px;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      color: #333;
    }

    /* Step selector for GRF curve */
    .step-select {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .step-select select {
      padding: 10px;
      border: 2px solid #667eea;
      border-radius: 8px;
      font-size: 14px;
      outline: none;
      width: 100%;
    }

    footer {
      margin-top: 18px;
      text-align: center;
      color: rgba(255,255,255,0.9);
      font-size: 12px;
    }
  </style>
</head>

<body>
<div class="container">
  <h1>üèÉ Gait Biodynamics Lab</h1>
  <p class="subtitle">
    Camera (set 120fps) + Upload High-FPS Video (e.g., 240fps) ‚Ä¢ Seek + Frame-step ‚Ä¢ Per-step GRF-time proxy curves ‚Ä¢ Application is developed by Ng Jun Wei
  </p>

  <div id="status" class="status loading"><span class="loading-spinner"></span> Initializing‚Ä¶</div>

  <div class="info-section">
    <h3>üë§ Subject & View</h3>
    <div class="grid">
      <div>
        <label>View Mode</label>
        <select id="viewMode">
          <option value="sagittal" selected>Sagittal (Side View)</option>
          <option value="frontal">Frontal (Front/Back View)</option>
        </select>
        <div class="hint">Sagittal: overstride ‚Ä¢ Frontal: collapser + crossover + knee drift proxy.</div>
      </div>
      <div>
        <label>Sex</label>
        <select id="subjectSex">
          <option value="male">Male</option>
          <option value="female">Female</option>
        </select>
      </div>
      <div>
        <label>Age (years)</label>
        <input type="number" id="subjectAge" min="1" max="120" value="30">
      </div>
      <div>
        <label>Mass (kg)</label>
        <input type="number" id="subjectMass" min="20" max="300" step="0.1" value="70">
      </div>
      <div>
        <label>Height (cm)</label>
        <input type="number" id="subjectHeight" min="100" max="250" step="0.1" value="170">
      </div>
    </div>
    <div class="tiny">
      Tip: true 240fps is best via uploaded slow-mo video. Browser decoding may deliver fewer frames on some devices, but the seek + frame-step helps review precisely.
    </div>
  </div>

  <div class="main-content">
    <div class="video-section">
      <div id="videoContainer">
        <div class="fps-indicator" id="fpsDisplay">FPS: 0</div>
        <video id="webcam" playsinline muted></video>
        <canvas id="canvas"></canvas>
      </div>

      <div class="controls">
        <button id="startCamBtn" disabled>Start Camera</button>
        <button id="loadVideoBtn" disabled>Upload Video</button>
        <button id="playPauseBtn" disabled>Play</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="recordBtn" disabled>Start Recording</button>
        <button id="exportBtn" disabled>Export XLSX</button>
        <button id="snapshotBtn" disabled>Snapshot PNG</button>
      </div>

      <!-- Uploaded video controls -->
      <div class="video-controls" id="videoControlsPanel">
        <div class="vc-row">
          <div class="seek-row">
            <div class="mono">Seek</div>
            <input id="seekBar" type="range" min="0" max="1000" value="0" step="1">
            <div class="mono" id="timeLabel">0.000 / 0.000</div>
          </div>

          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap: 12px;">
            <div>
              <label>Assumed Video FPS (for frame-step)</label>
              <input id="assumedFps" type="number" min="10" max="1000" step="1" value="240">
              <div class="hint">If your video is 120fps ‚Äúnormal‚Äù, set to 120. This only affects ¬±1-frame stepping.</div>
            </div>
            <div>
              <label>Frame Step Size</label>
              <select id="frameStepMode">
                <option value="1" selected>¬±1 frame</option>
                <option value="2">¬±2 frames</option>
                <option value="5">¬±5 frames</option>
              </select>
              <div class="hint">Use larger steps if your device lags during scrubbing.</div>
            </div>
          </div>

          <div class="vc-buttons">
            <button id="stepBackBtn" disabled>‚óÄÔ∏é -Frame</button>
            <button id="stepFwdBtn" disabled>Frame+ ‚ñ∂Ô∏é</button>
            <button id="skipBackBtn" disabled>‚óÄÔ∏é -0.1s</button>
            <button id="skipFwdBtn" disabled>+0.1s ‚ñ∂Ô∏é</button>
          </div>

          <div class="mono" id="videoMetaLabel">Video: (not loaded)</div>
        </div>
      </div>

      <input id="videoFile" type="file" accept="video/*" style="display:none;">
      <div class="row-note" id="sourceNote">Source: none</div>
    </div>

    <div class="analysis-panel">
      <h3 style="color:#667eea; margin-bottom:10px;">
        Real-Time (Per-Step)
        <span class="pill" id="modePill">SAGITTAL</span>
        <span class="pill" id="sourcePill" style="background:#2c3e50;">NONE</span>
      </h3>

      <div class="gait-phase">
        <div class="metric-label">Current Phase</div>
        <div class="metric-value" id="gaitPhase">Standing</div>
        <div class="phase-indicator">
          <div class="phase-dot" id="phase1">IC</div>
          <div class="phase-dot" id="phase2">MS</div>
          <div class="phase-dot" id="phase3">TO</div>
          <div class="phase-dot" id="phase4">SW</div>
        </div>
        <div class="tiny" style="margin-top:10px;">IC: Initial Contact ‚Ä¢ MS: Mid Stance ‚Ä¢ TO: Toe Off ‚Ä¢ SW: Swing</div>
      </div>

      <div class="metrics">
        <div class="metric-card">
          <div class="metric-label">Cadence (last ~8 IC)</div>
          <div class="metric-value" id="cadence">0<span class="metric-unit">steps/min</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Stance Time Avg (last ~6)</div>
          <div class="metric-value" id="stanceTime">0<span class="metric-unit">s</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Swing Time Avg (last ~6)</div>
          <div class="metric-value" id="swingTime">0<span class="metric-unit">s</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Stride Length Avg (last ~6)</div>
          <div class="metric-value" id="strideLength">0<span class="metric-unit">cm</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Knee Flexion Mid-Stance (L) - last</div>
          <div class="metric-value" id="kneeMSL">0<span class="metric-unit">¬∞</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Knee Flexion Mid-Stance (R) - last</div>
          <div class="metric-value" id="kneeMSR">0<span class="metric-unit">¬∞</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Pelvic Drop / Obliquity (Frontal proxy) - last</div>
          <div class="metric-value" id="pelvicTilt">0<span class="metric-unit">¬∞</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Vertical Oscillation (VO) - live</div>
          <div class="metric-value" id="vertOsc">0<span class="metric-unit">cm</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label" id="modeMetricLabel">Overstride Risk (last IC)</div>
          <div class="metric-value" id="modeMetricValue">Low</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">GRF Peak (last step, proxy)</div>
          <div class="metric-value" id="grfPeak">0<span class="metric-unit">BW</span></div>
        </div>
        <div class="metric-card">
          <div class="metric-label">GRF Time-to-Peak (last step, proxy)</div>
          <div class="metric-value" id="grfTTP">0<span class="metric-unit">ms</span></div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="metric-label">Detected Issues (per-step)</div>
        <div class="issues-list" id="issuesList">
          <div style="text-align:center; color:#999; padding:18px;">No issues detected yet</div>
        </div>
      </div>

      <div class="tiny">
        GRF proxy curve uses ankle vertical deceleration during stance (normalized to BW proxy). It‚Äôs not a true force plate.
      </div>
    </div>
  </div>

  <!-- Charts section: ONLY GRF curve step + deficiency amount displayed in chart -->
  <div class="charts-section">
    <h3>üìä GRF Curve + Deficiency Sub-scores (Selected Step)</h3>

    <div class="chart-container">
      <div class="step-select">
        <div class="mono">GRF Curve Step</div>
        <select id="stepPicker">
          <option value="">(no steps yet)</option>
        </select>
      </div>
      <canvas id="grfCurveChart"></canvas>
      <div class="tiny">
        BW curve = GRF proxy. Right axis overlays show 0‚Äì100 sub-scores: Collapser / Overstrider / Bouncer / Crossover.
      </div>
    </div>
  </div>

  <div class="tiny" style="text-align:center; margin-top:10px;">
    ¬© 2025 Ng Jun Wei. All rights reserved.
  </div>
</div>

<script>
  // ============================================================
  // Environment
  // ============================================================
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  const useVFC = typeof HTMLVideoElement !== 'undefined' && 'requestVideoFrameCallback' in HTMLVideoElement.prototype;

  // ============================================================
  // DOM
  // ============================================================
  const statusDiv = document.getElementById('status');
  const fpsDisplay = document.getElementById('fpsDisplay');

  const startCamBtn = document.getElementById('startCamBtn');
  const loadVideoBtn = document.getElementById('loadVideoBtn');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const stopBtn = document.getElementById('stopBtn');
  const recordBtn = document.getElementById('recordBtn');
  const exportBtn = document.getElementById('exportBtn');
  const snapshotBtn = document.getElementById('snapshotBtn');

  const videoFile = document.getElementById('videoFile');
  const webcam = document.getElementById('webcam');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const viewModeEl = document.getElementById('viewMode');
  const modePill = document.getElementById('modePill');
  const sourcePill = document.getElementById('sourcePill');
  const sourceNote = document.getElementById('sourceNote');
  const modeMetricLabel = document.getElementById('modeMetricLabel');
  const modeMetricValue = document.getElementById('modeMetricValue');

  const subjectSexEl = document.getElementById('subjectSex');
  const subjectAgeEl = document.getElementById('subjectAge');
  const subjectMassEl = document.getElementById('subjectMass');
  const subjectHeightEl = document.getElementById('subjectHeight');

  // Uploaded video controls
  const videoControlsPanel = document.getElementById('videoControlsPanel');
  const seekBar = document.getElementById('seekBar');
  const timeLabel = document.getElementById('timeLabel');
  const assumedFpsEl = document.getElementById('assumedFps');
  const frameStepModeEl = document.getElementById('frameStepMode');
  const stepBackBtn = document.getElementById('stepBackBtn');
  const stepFwdBtn = document.getElementById('stepFwdBtn');
  const skipBackBtn = document.getElementById('skipBackBtn');
  const skipFwdBtn = document.getElementById('skipFwdBtn');
  const videoMetaLabel = document.getElementById('videoMetaLabel');

  // GRF curve selector
  const stepPicker = document.getElementById('stepPicker');

  // ============================================================
  // State
  // ============================================================
  let detector = null;

  let sourceMode = 'none'; // 'camera' | 'video' | 'none'
  let mediaStream = null;
  let videoObjectUrl = null;

  let isRunning = false;
  let isRecording = false;

  let animId = null;
  let vfcActive = false;

  let loopFrames = 0;
  let loopFpsT0 = 0;

  // ============================================================
  // Per-step gait state (concurrent L/R)
  // ============================================================
  function makeFootState(side) {
    return {
      side,
      groundY: null,
      contact: false,
      prev: { t: 0, x: 0, y: 0, ok: false },
      prevVY: 0,
      active: null,
      lastTO: null,
      lastIC: null,
      lastIC_hipX: null
    };
  }

  const gait = {
    feet: { L: makeFootState('L'), R: makeFootState('R') },
    steps: [],
    icTimes: [],
    recentWindow: 6,
    vo: { baselineY: null, maxDevPx: 0, windowFrames: 0, lastVOcm: 0 }
  };

  let detectedIssues = new Set();

  // ============================================================
  // Charts (ONLY GRF chart kept)
  // ============================================================
  let grfCurveChart;

  function initCharts() {
    const commonOptions = {
      responsive: true,
      maintainAspectRatio: true,
      animation: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { display: true },
        title: { display: true, text: 'GRF Proxy (BW) vs time from IC' },
        subtitle: { display: true, text: 'Select a step to view GRF curve + deficiency sub-scores' }
      }
    };

    grfCurveChart = new Chart(document.getElementById('grfCurveChart'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'GRF Proxy (BW)',
            data: [],
            tension: 0.25,
            pointRadius: 0
          },
          // Right-axis: 4 separate 0‚Äì100 sub-score lines
          {
            label: 'Collapser (0‚Äì100)',
            data: [],
            tension: 0,
            pointRadius: 0,
            yAxisID: 'y2',
            borderDash: [6, 6]
          },
          {
            label: 'Overstrider (0‚Äì100)',
            data: [],
            tension: 0,
            pointRadius: 0,
            yAxisID: 'y2',
            borderDash: [10, 6]
          },
          {
            label: 'Bouncer (0‚Äì100)',
            data: [],
            tension: 0,
            pointRadius: 0,
            yAxisID: 'y2',
            borderDash: [2, 6]
          },
          {
            label: 'Crossover (0‚Äì100)',
            data: [],
            tension: 0,
            pointRadius: 0,
            yAxisID: 'y2',
            borderDash: [14, 6, 2, 6]
          }
        ]
      },
      options: {
        ...commonOptions,
        scales: {
          x: { title: { display: true, text: 'ms from IC' } },
          y: { title: { display: true, text: 'BW (proxy)' }, suggestedMin: 1.0, suggestedMax: 3.2 },
          y2: {
            position: 'right',
            title: { display: true, text: 'Deficiency sub-scores (0‚Äì100)' },
            min: 0,
            max: 100,
            grid: { drawOnChartArea: false }
          }
        }
      }
    });
  }

  function numOrNull(v) {
    return (typeof v === 'number' && isFinite(v)) ? v : null;
  }

  function rebuildStepPicker() {
    if (!gait.steps.length) {
      stepPicker.innerHTML = '<option value="">(no steps yet)</option>';
      return;
    }
    const current = stepPicker.value;
    const opts = gait.steps.slice(-200).map(s => {
      const ttp = (typeof s.grfTimeToPeakMs === 'number') ? `${Math.round(s.grfTimeToPeakMs)}ms` : '‚Äî';
      const peak = (typeof s.grfPeakBW === 'number') ? s.grfPeakBW.toFixed(2) : '‚Äî';
      const score = (typeof s.deficiencyScore === 'number') ? `${Math.round(s.deficiencyScore)}/100` : '‚Äî';
      return `<option value="${s.idx}">#${s.idx} (${s.side}) peak ${peak}BW, TTP ${ttp}, Def ${score}</option>`;
    }).join('');
    stepPicker.innerHTML = opts;

    if (current && gait.steps.some(s => String(s.idx) === current)) {
      stepPicker.value = current;
    } else {
      stepPicker.value = String(gait.steps[gait.steps.length - 1].idx);
    }
    renderSelectedGRFCurve();
  }

  function renderSelectedGRFCurve() {
    const v = stepPicker.value;
    if (!v || !grfCurveChart) return;
    const step = gait.steps.find(s => String(s.idx) === v);

    if (!step || !step.grfCurve || !step.grfCurve.length) {
      grfCurveChart.data.labels = [];
      grfCurveChart.data.datasets[0].data = [];
      grfCurveChart.data.datasets[1].data = [];
      grfCurveChart.data.datasets[2].data = [];
      grfCurveChart.data.datasets[3].data = [];
      grfCurveChart.data.datasets[4].data = [];
      grfCurveChart.options.plugins.title.text = 'GRF Proxy (BW) vs time from IC';
      grfCurveChart.options.plugins.subtitle.text = 'No GRF curve for selected step.';
      grfCurveChart.update('none');
      return;
    }

    const labels = step.grfCurve.map(p => String(Math.round(p.tRelMs)));
    const bw = step.grfCurve.map(p => p.bw);

    // Subscores (0‚Äì100) ‚Äî flat overlay lines across stance time
    const subs = step.deficiencySubscores || computeDeficiencySubscores(step);
    const collLine = step.grfCurve.map(_ => subs.collapser);
    const overLine = step.grfCurve.map(_ => subs.overstrider);
    const bounceLine = step.grfCurve.map(_ => subs.bouncer);
    const crossLine = step.grfCurve.map(_ => subs.crossover);

    grfCurveChart.data.labels = labels;
    grfCurveChart.data.datasets[0].data = bw;
    grfCurveChart.data.datasets[1].data = collLine;
    grfCurveChart.data.datasets[2].data = overLine;
    grfCurveChart.data.datasets[3].data = bounceLine;
    grfCurveChart.data.datasets[4].data = crossLine;

    const bits = [];
    if (step.tags?.includes('Overstrider')) bits.push(`Overstride FSR ${step.overstrideFSR?.toFixed(2) ?? '‚Äî'}`);
    if (step.tags?.includes('Collapser')) bits.push(`Pelvic drop ${step.pelvicTiltMaxDeg?.toFixed(1) ?? '‚Äî'}¬∞`);
    if (step.tags?.includes('Bouncer')) bits.push(`VO ${step.voCmAtIC?.toFixed(1) ?? '‚Äî'}cm`);
    if (step.tags?.includes('Crossover')) bits.push(`Crossover (midline)`);

    const total = (typeof step.deficiencyScore === 'number') ? Math.round(step.deficiencyScore) : Math.round(computeDeficiencyScore(step));
    grfCurveChart.options.plugins.title.text = `Step #${step.idx} (${step.side}) ‚Äî GRF Proxy`;
    grfCurveChart.options.plugins.subtitle.text =
      `Total Def: ${total}/100 ‚Ä¢ Coll ${Math.round(subs.collapser)} ‚Ä¢ Over ${Math.round(subs.overstrider)} ‚Ä¢ Bounce ${Math.round(subs.bouncer)} ‚Ä¢ Cross ${Math.round(subs.crossover)}`
      + (bits.length ? ` ‚Ä¢ ${bits.join(' ‚Ä¢ ')}` : '');

    grfCurveChart.update('none');
  }

  // ============================================================
  // UI helpers
  // ============================================================
  function viewMode() { return viewModeEl.value; }

  function setStatus(type, html) {
    statusDiv.className = 'status ' + type;
    statusDiv.innerHTML = html;
  }

  function syncModeUI() {
    const m = viewMode();
    modePill.textContent = m.toUpperCase();
    if (m === 'sagittal') {
      modePill.style.background = '#667eea';
      modeMetricLabel.textContent = 'Overstride Risk (last IC)';
      if (!modeMetricValue.textContent) modeMetricValue.textContent = 'Low';
    } else {
      modePill.style.background = '#e67e22';
      modeMetricLabel.textContent = 'Knee Medial Drift (proxy) - live';
      if (!modeMetricValue.textContent.includes('¬∞')) modeMetricValue.textContent = '0.0¬∞';
    }
  }

  function setSourceUI(mode) {
    sourceMode = mode;
    const label = mode.toUpperCase();
    sourcePill.textContent = label;
    sourcePill.style.background = (mode === 'camera') ? '#16a085' : (mode === 'video') ? '#f39c12' : '#2c3e50';
    sourceNote.textContent = (mode === 'camera')
      ? 'Source: camera stream'
      : (mode === 'video')
        ? 'Source: uploaded video file'
        : 'Source: none';

    videoControlsPanel.style.display = (mode === 'video') ? 'block' : 'none';
  }

  function setPhaseIndicator(phase) {
    for (let i = 1; i <= 4; i++) {
      const dot = document.getElementById('phase' + i);
      dot.classList.toggle('active', i === phase);
    }
  }

  // ============================================================
  // Canvas sizing (helps ensure stick figure is visible)
  // ============================================================
  function resizeCanvasToVideo() {
    const w = webcam.videoWidth || 640;
    const h = webcam.videoHeight || 480;
    if (canvas.width !== w) canvas.width = w;
    if (canvas.height !== h) canvas.height = h;
  }

  // ============================================================
  // Reset state
  // ============================================================
  function resetGaitAll() {
    gait.feet.L = makeFootState('L');
    gait.feet.R = makeFootState('R');
    gait.steps = [];
    gait.icTimes = [];
    gait.vo = { baselineY: null, maxDevPx: 0, windowFrames: 0, lastVOcm: 0 };
    detectedIssues = new Set();

    document.getElementById('issuesList').innerHTML =
      '<div style="text-align:center; color:#999; padding:18px;">No issues detected yet</div>';

    document.getElementById('cadence').innerHTML = `0<span class="metric-unit">steps/min</span>`;
    document.getElementById('stanceTime').innerHTML = `0<span class="metric-unit">s</span>`;
    document.getElementById('swingTime').innerHTML = `0<span class="metric-unit">s</span>`;
    document.getElementById('strideLength').innerHTML = `0<span class="metric-unit">cm</span>`;
    document.getElementById('kneeMSL').innerHTML = `0<span class="metric-unit">¬∞</span>`;
    document.getElementById('kneeMSR').innerHTML = `0<span class="metric-unit">¬∞</span>`;
    document.getElementById('pelvicTilt').innerHTML = `0<span class="metric-unit">¬∞</span>`;
    document.getElementById('vertOsc').innerHTML = `0<span class="metric-unit">cm</span>`;
    document.getElementById('grfPeak').innerHTML = `0<span class="metric-unit">BW</span>`;
    document.getElementById('grfTTP').innerHTML = `0<span class="metric-unit">ms</span>`;
    document.getElementById('gaitPhase').textContent = 'Standing';
    setPhaseIndicator(1);

    exportBtn.disabled = true;

    if (grfCurveChart) {
      grfCurveChart.data.labels = [];
      grfCurveChart.data.datasets[0].data = [];
      grfCurveChart.data.datasets[1].data = [];
      grfCurveChart.data.datasets[2].data = [];
      grfCurveChart.data.datasets[3].data = [];
      grfCurveChart.data.datasets[4].data = [];
      grfCurveChart.options.plugins.title.text = 'GRF Proxy (BW) vs time from IC';
      grfCurveChart.options.plugins.subtitle.text = 'Select a step to view GRF curve + deficiency sub-scores';
      grfCurveChart.update('none');
    }
    rebuildStepPicker();
  }

  // ============================================================
  // TF backend init
  // ============================================================
  async function initTFBackend() {
    await tf.ready();
    const preferred = (isIOS || isSafari) ? ['webgl', 'cpu'] : ['webgpu', 'webgl', 'cpu'];
    let ok = false;
    for (const b of preferred) {
      try {
        await tf.setBackend(b);
        await tf.ready();
        ok = true;
        break;
      } catch (_) {}
    }
    if (!ok) throw new Error('No TFJS backend could be initialized.');
    return tf.getBackend();
  }

  async function initModel() {
    setStatus('loading', '<span class="loading-spinner"></span> Loading TensorFlow backend‚Ä¶');
    const backend = await initTFBackend();

    setStatus('loading', `<span class="loading-spinner"></span> Loading MoveNet (backend: ${backend})‚Ä¶`);
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {
        modelType: (isIOS || isSafari)
          ? poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
          : poseDetection.movenet.modelType.SINGLEPOSE_THUNDER,
        enableTracking: true,
        trackerType: poseDetection.TrackerType.BoundingBox
      }
    );

    initCharts();
    syncModeUI();
    setSourceUI('none');
    setStatus('ready', `‚úì Model Ready (backend: ${backend}) ‚Äî Choose Camera or Upload Video`);
    startCamBtn.disabled = false;
    loadVideoBtn.disabled = false;
  }

  // ============================================================
  // Media cleanup
  // ============================================================
  function stopLoops() {
    isRunning = false;
    if (animId) cancelAnimationFrame(animId);
    animId = null;
    vfcActive = false;
  }

  function stopStream() {
    if (mediaStream) {
      mediaStream.getTracks().forEach(t => t.stop());
      mediaStream = null;
    }
  }

  function revokeVideoUrl() {
    if (videoObjectUrl) {
      URL.revokeObjectURL(videoObjectUrl);
      videoObjectUrl = null;
    }
  }

  function clearVideoSource() {
    webcam.pause();
    webcam.removeAttribute('src');
    webcam.srcObject = null;
    webcam.load();
  }

  function setRecordingUI() {
    recordBtn.classList.toggle('recording', isRecording);
    recordBtn.textContent = isRecording ? 'Stop Recording' : 'Start Recording';
  }

  function stopRecordingIfNeeded() {
    if (!isRecording) return;
    isRecording = false;
    setRecordingUI();
    exportBtn.disabled = gait.steps.length === 0;
    setStatus('ready', `‚úì Recording stopped ‚Äî ${gait.steps.length} steps captured`);
    rebuildStepPicker();
    renderSelectedGRFCurve();
  }

  function stopAll() {
    // ensure recording stops cleanly (no toggle flip confusion)
    stopRecordingIfNeeded();

    stopLoops();
    stopStream();
    revokeVideoUrl();
    clearVideoSource();

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    fpsDisplay.textContent = 'FPS: 0';

    setSourceUI('none');

    playPauseBtn.disabled = true;
    stopBtn.disabled = true;
    recordBtn.disabled = true;
    exportBtn.disabled = true;
    snapshotBtn.disabled = true;

    stepBackBtn.disabled = true;
    stepFwdBtn.disabled = true;
    skipBackBtn.disabled = true;
    skipFwdBtn.disabled = true;

    setStatus('ready', 'Stopped. Choose Camera or Upload Video.');
  }

  // ============================================================
  // Camera start
  // ============================================================
  async function startCamera() {
    try {
      stopAll();
      resetGaitAll();

      setStatus('loading', '<span class="loading-spinner"></span> Starting camera‚Ä¶');
      setSourceUI('camera');

      webcam.muted = true;
      webcam.playsInline = true;
      webcam.setAttribute('playsinline', '');
      webcam.setAttribute('muted', '');

      const tryConstraints = [
        { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 120, max: 120 } }, audio: false },
        { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 },  frameRate: { ideal: 60,  max: 60  } }, audio: false },
        { video: { facingMode: { ideal: 'environment' } }, audio: false }
      ];

      let stream = null, lastErr = null;
      for (const c of tryConstraints) {
        try { stream = await navigator.mediaDevices.getUserMedia(c); break; }
        catch (e) { lastErr = e; }
      }
      if (!stream) throw lastErr || new Error('Unable to access camera');

      mediaStream = stream;
      webcam.srcObject = stream;

      await new Promise(res => webcam.onloadedmetadata = () => res());
      await webcam.play();

      resizeCanvasToVideo();

      const track = stream.getVideoTracks()[0];
      const settings = track.getSettings ? track.getSettings() : {};
      const gotFps = settings.frameRate ? Math.round(settings.frameRate) : null;

      stopBtn.disabled = false;
      recordBtn.disabled = false;
      snapshotBtn.disabled = false;
      playPauseBtn.disabled = true;

      setRecordingUI();

      setStatus('ready', gotFps && gotFps < 90
        ? `‚ö†Ô∏è Camera delivered ~${gotFps} fps. Analysis works; GRF timing is less crisp than true 120fps.`
        : 'üé• Camera active. Ready.');

      isRunning = true;
      loopFrames = 0;
      loopFpsT0 = performance.now();
      loopPose(performance.now());
    } catch (e) {
      setSourceUI('none');
      setStatus('error', '‚úó Camera Error: ' + (e?.message || e));
      console.error(e);
    }
  }

  // ============================================================
  // Video upload
  // ============================================================
  async function loadVideoFile(file) {
    try {
      stopAll();
      resetGaitAll();

      setSourceUI('video');
      setStatus('loading', '<span class="loading-spinner"></span> Loading video‚Ä¶');

      revokeVideoUrl();
      videoObjectUrl = URL.createObjectURL(file);

      webcam.muted = true;
      webcam.playsInline = true;
      webcam.setAttribute('playsinline', '');
      webcam.setAttribute('muted', '');

      webcam.src = videoObjectUrl;
      webcam.load();

      await new Promise((res, rej) => {
        const onLoaded = () => res();
        const onErr = () => rej(new Error('Failed to load video'));
        webcam.addEventListener('loadeddata', onLoaded, { once: true });
        webcam.addEventListener('error', onErr, { once: true });
      });

      resizeCanvasToVideo();

      stopBtn.disabled = false;
      recordBtn.disabled = false;
      snapshotBtn.disabled = false;
      playPauseBtn.disabled = false;

      stepBackBtn.disabled = false;
      stepFwdBtn.disabled = false;
      skipBackBtn.disabled = false;
      skipFwdBtn.disabled = false;

      setRecordingUI();
      playPauseBtn.textContent = 'Play';

      updateSeekUI();
      videoMetaLabel.textContent = `Video: ${webcam.videoWidth}x${webcam.videoHeight}, duration ${formatTime(webcam.duration)} (s), VFC: ${useVFC ? 'yes' : 'no'}`;

      setStatus('ready', 'üìº Video loaded. Press Play, or scrub using the seek bar / frame-step.');
      isRunning = false;
      fpsDisplay.textContent = 'FPS: 0';
    } catch (e) {
      setSourceUI('none');
      setStatus('error', '‚úó Video Error: ' + (e?.message || e));
      console.error(e);
    }
  }

  async function togglePlayPause() {
    if (sourceMode !== 'video') return;
    if (!webcam.src) return;

    if (webcam.paused) {
      await webcam.play();
      resizeCanvasToVideo();
      playPauseBtn.textContent = 'Pause';
      startVideoAnalysisLoop();
    } else {
      webcam.pause();
      playPauseBtn.textContent = 'Play';
      stopLoops();
    }
  }

  function startVideoAnalysisLoop() {
    stopLoops();
    isRunning = true;
    loopFrames = 0;
    loopFpsT0 = performance.now();

    if (useVFC) {
      vfcActive = true;
      const cb = (now, metadata) => {
        if (!vfcActive || !isRunning || webcam.paused || webcam.ended) return;
        resizeCanvasToVideo();
        const tMs = (metadata && typeof metadata.mediaTime === 'number')
          ? metadata.mediaTime * 1000
          : (webcam.currentTime * 1000);
        loopPose(tMs);
        webcam.requestVideoFrameCallback(cb);
      };
      webcam.requestVideoFrameCallback(cb);
    } else {
      const raf = () => {
        if (!isRunning || webcam.paused || webcam.ended) return;
        resizeCanvasToVideo();
        loopPose(webcam.currentTime * 1000);
        animId = requestAnimationFrame(raf);
      };
      animId = requestAnimationFrame(raf);
    }
  }

  // ============================================================
  // Loop + pose
  // ============================================================
  async function loopPose(tNowMs) {
    if (!isRunning) return;

    loopFrames++;
    const nowPerf = performance.now();
    if ((nowPerf - loopFpsT0) >= 1000) {
      const loopFps = Math.round(loopFrames * 1000 / (nowPerf - loopFpsT0));
      fpsDisplay.textContent = `FPS: ${loopFps}` + (sourceMode === 'video' ? ' (analysis)' : '');
      loopFrames = 0;
      loopFpsT0 = nowPerf;
    }

    try {
      const poses = await detector.estimatePoses(webcam);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (poses && poses.length > 0 && poses[0]?.keypoints?.length) {
        const kps = poses[0].keypoints;
        drawSkeleton(kps);
        analyzePerFrame(kps, tNowMs);
      }
    } catch (e) {
      console.error('Pose error:', e);
    }

    if (sourceMode === 'camera') {
      animId = requestAnimationFrame(() => loopPose(performance.now()));
    }
  }

  // ============================================================
  // Drawing
  // ============================================================
  function drawSkeleton(keypoints) {
    const conns = [
      { a: 5, b: 7, c: '#3498db' }, { a: 7, b: 9, c: '#3498db' },
      { a: 5, b: 11, c: '#3498db' }, { a: 11, b: 13, c: '#3498db' }, { a: 13, b: 15, c: '#3498db' },
      { a: 6, b: 8, c: '#2ecc71' }, { a: 8, b: 10, c: '#2ecc71' },
      { a: 6, b: 12, c: '#2ecc71' }, { a: 12, b: 14, c: '#2ecc71' }, { a: 14, b: 16, c: '#2ecc71' },
      { a: 5, b: 6, c: '#9b59b6' }, { a: 11, b: 12, c: '#9b59b6' }
    ];

    ctx.lineWidth = 5;
    for (const conn of conns) {
      const p1 = keypoints[conn.a], p2 = keypoints[conn.b];
      if (p1?.score > 0.3 && p2?.score > 0.3) {
        ctx.strokeStyle = conn.c;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    }

    for (let i = 0; i < keypoints.length; i++) {
      const kp = keypoints[i];
      if (kp?.score > 0.3) {
        ctx.beginPath();
        ctx.arc(kp.x, kp.y, 8, 0, 2*Math.PI);
        if ([5,7,9,11,13,15].includes(i)) ctx.fillStyle = '#3498db';
        else if ([6,8,10,12,14,16].includes(i)) ctx.fillStyle = '#2ecc71';
        else ctx.fillStyle = '#9b59b6';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }

  // ============================================================
  // Deficiency thresholds + persistence (sex-aware)
  // ============================================================
  function sex() { return subjectSexEl.value; }

  function thresholds() {
    const isF = sex() === 'female';

    return {
      collapser: {
        moderate: isF ? 7 : 6,
        high:     isF ? 11 : 10
      },
      overstride: {
        moderate: isF ? 0.22 : 0.20,
        high:     isF ? 0.32 : 0.30
      },
      bouncer: {
        voCm: isF ? 11 : 10,
        voRatio: 0.06
      },
      crossover: {
        narrowStepWidthCm: 5
      },
      persistence: { window: 5, minCount: 3 }
    };
  }

  function recentCount(predicateFn, window = 5) {
    const s = gait.steps.slice(-window);
    let c = 0;
    for (const step of s) if (predicateFn(step)) c++;
    return c;
  }

  function shouldPersist(predicateFn) {
    const th = thresholds().persistence;
    return recentCount(predicateFn, th.window) >= th.minCount;
  }

  // ============================================================
  // Analysis
  // ============================================================
  function analyzePerFrame(kps, tNowMs) {
    const subject = {
      sex: subjectSexEl.value,
      age: parseFloat(subjectAgeEl.value || '0'),
      mass: parseFloat(subjectMassEl.value || '0'),
      height: parseFloat(subjectHeightEl.value || '0')
    };

    const m = viewMode();

    const get = (i) => (kps[i] && kps[i].score > 0.3) ? kps[i] : null;

    const nose = get(0);
    const hipL = get(11), hipR = get(12);
    const kneeL = get(13), kneeR = get(14);
    const ankleL = get(15), ankleR = get(16);

    if (!ankleL && !ankleR) return;

    const pxToCm = estimatePxToCm(nose, ankleL, ankleR, subject.height);

    const pelvicTiltDeg = computePelvicTiltDeg(hipL, hipR);
    document.getElementById('pelvicTilt').innerHTML = `${pelvicTiltDeg.toFixed(1)}<span class="metric-unit">¬∞</span>`;

    const hipMidY = midY(hipL, hipR);
    let voCmLive = gait.vo.lastVOcm;
    if (hipMidY != null && pxToCm) {
      voCmLive = updateVerticalOscillation(hipMidY, pxToCm);
      document.getElementById('vertOsc').innerHTML = `${voCmLive.toFixed(1)}<span class="metric-unit">cm</span>`;
      const h = Math.max(1, subject.height || 1);
      const voRatio = voCmLive / h;
      const b = thresholds().bouncer;
      if ((voCmLive > b.voCm || voRatio > b.voRatio) && shouldPersist(s => (s.voCmAtIC ?? 0) > b.voCm || (s.voRatioAtIC ?? 0) > b.voRatio)) {
        addIssue('warning', 'Bouncer: excessive vertical oscillation (VO)', 'Bouncer');
      }
    }

    const kneeDegL = (hipL && kneeL && ankleL) ? calculateAngle(hipL, kneeL, ankleL) : null;
    const kneeDegR = (hipR && kneeR && ankleR) ? calculateAngle(hipR, kneeR, ankleR) : null;

    if (m === 'frontal') {
      const drift = computeKneeMedialDriftProxyDeg(hipL, kneeL, ankleL, hipR, kneeR, ankleR);
      modeMetricValue.textContent = `${drift.toFixed(1)}¬∞`;
    }

    handleFoot('L', tNowMs, ankleL, hipL, hipR, kneeDegL, pelvicTiltDeg, pxToCm, m, voCmLive, subject.height);
    handleFoot('R', tNowMs, ankleR, hipL, hipR, kneeDegR, pelvicTiltDeg, pxToCm, m, voCmLive, subject.height);

    updatePhaseUI(gait.feet.L.contact, gait.feet.R.contact);
    updateCadenceUI();
    updateRollingUI();

    exportBtn.disabled = gait.steps.length === 0;
  }

  function handleFoot(side, tNow, ankle, hipL, hipR, kneeDeg, pelvicTiltDeg, pxToCm, mode, voCmLive, heightCm) {
    const f = gait.feet[side];
    if (!ankle) return;

    const alpha = 0.05;
    if (f.groundY == null) f.groundY = ankle.y;
    f.groundY = (1 - alpha) * f.groundY + alpha * Math.max(f.groundY, ankle.y);

    const thrOn = 18, thrOff = 26;
    const dist = f.groundY - ankle.y;

    let contactNow = f.contact;
    if (!f.contact && dist < thrOn) contactNow = true;
    if (f.contact && dist > thrOff) contactNow = false;

    const dt = Math.max(1e-3, (tNow - f.prev.t) / 1000);
    const vY = (f.prev.ok) ? (ankle.y - f.prev.y) / dt : 0;
    const aY = (dt > 0) ? (vY - (f.prevVY || 0)) / dt : 0;
    f.prevVY = vY;

    const ic = (!f.contact && contactNow && vY > -400);
    const to = (f.contact && !contactNow);

    if (ic) onInitialContact(side, tNow, ankle, hipL, hipR, pxToCm, mode, voCmLive, heightCm);
    if (f.active && f.active.inStance) {
      if (typeof kneeDeg === 'number') f.active.samples.push({ t: tNow, kneeDeg });

      f.active.pelvicTiltMaxDeg = Math.max(f.active.pelvicTiltMaxDeg, pelvicTiltDeg);

      const decel = Math.max(0, -aY);
      const bw = mapDecelProxyToBW(decel);
      const tRelMs = tNow - f.active.tIC_ms;

      if ((f.active.grfCurve.length === 0) || (tRelMs - f.active.grfCurve[f.active.grfCurve.length - 1].tRelMs >= 8)) {
        f.active.grfCurve.push({ tRelMs, bw });
      }

      const earlyWindowMs = 140;
      if (tRelMs <= earlyWindowMs) {
        if (decel > f.active.grfProxy.peak) {
          f.active.grfProxy.peak = decel;
          f.active.grfProxy.tPeak = tNow;
        }
      }
    }

    if (to) onToeOff(side, tNow);

    f.contact = contactNow;
    f.prev = { t: tNow, x: ankle.x, y: ankle.y, ok: true };
  }

  function onInitialContact(side, tIC, ankle, hipL, hipR, pxToCm, mode, voCmLive, heightCm) {
    if (!isRecording) return;

    const f = gait.feet[side];

    const minICGapMs = 220;
    if (f.lastIC && (tIC - f.lastIC) < minICGapMs) return;

    const hipMidX = midX(hipL, hipR);
    const hipForLeg = (side === 'L') ? hipL : hipR;
    const hipLegX = (hipForLeg && hipForLeg.score > 0.3) ? hipForLeg.x : hipMidX;
    const hipLegY = (hipForLeg && hipForLeg.score > 0.3) ? hipForLeg.y : midY(hipL, hipR);

    const lastSame = findLastStepOfSide(side);
    if (lastSame && typeof lastSame.tTO_ms === 'number' && typeof lastSame.swingTimeS !== 'number') {
      lastSame.swingTimeS = (tIC - lastSame.tTO_ms) / 1000;
    }

    if (pxToCm && f.lastIC_hipX != null && hipMidX != null) {
      const strideCm = Math.abs(hipMidX - f.lastIC_hipX) * pxToCm;
      if (lastSame && typeof lastSame.strideCm !== 'number') lastSame.strideCm = strideCm;
    }

    f.active = {
      side,
      tIC_ms: tIC,
      tTO_ms: null,
      inStance: true,
      stanceTimeS: null,
      swingTimeS: null,
      strideCm: null,
      kneeMidStanceDeg: null,
      pelvicTiltMaxDeg: 0,
      samples: [],
      grfProxy: { peak: 0, tPeak: null },
      grfCurve: [],
      overstrideLevel: null,
      landingQuality: null,
      grfPeakBW: null,
      grfTimeToPeakMs: null,
      notes: '',
      overstrideFSR: null,
      crossover: null,
      stepWidthCmAtIC: null,
      voCmAtIC: (typeof voCmLive === 'number') ? voCmLive : null,
      voRatioAtIC: (typeof voCmLive === 'number' && typeof heightCm === 'number' && heightCm > 0) ? (voCmLive / heightCm) : null,
      tags: []
    };

    if (mode === 'sagittal') {
      const legLenPx = (hipLegX != null && hipLegY != null)
        ? Math.hypot(ankle.x - hipLegX, ankle.y - hipLegY)
        : null;

      const fsr = (legLenPx && legLenPx > 1 && hipMidX != null)
        ? (Math.abs(ankle.x - hipMidX) / legLenPx)
        : null;

      f.active.overstrideFSR = fsr;

      const os = computeOverstrideRisk_FSR(fsr);
      f.active.overstrideLevel = os.level;
      modeMetricValue.textContent = os.level;

      const th = thresholds().overstride;
      const highNow = (typeof fsr === 'number') && fsr >= th.high;
      const modNow  = (typeof fsr === 'number') && fsr >= th.moderate;

      if (highNow && shouldPersist(s => (s.overstrideFSR ?? 0) >= th.high)) {
        addIssue('critical', `${side}: Overstrider (FSR ${fsr.toFixed(2)})`, 'Overstrider');
        f.active.tags.push('Overstrider');
      } else if (modNow && shouldPersist(s => (s.overstrideFSR ?? 0) >= th.moderate)) {
        addIssue('warning', `${side}: Overstrider tendency (FSR ${fsr.toFixed(2)})`, 'Overstrider');
        f.active.tags.push('Overstrider');
      }
    }

    if (mode === 'frontal') {
      const midlineX = midX(hipL, hipR);
      if (midlineX != null) {
        let crossed = false;
        if (side === 'L') crossed = ankle.x > midlineX;
        if (side === 'R') crossed = ankle.x < midlineX;
        f.active.crossover = crossed;

        if (pxToCm && gait.feet.L.prev.ok && gait.feet.R.prev.ok) {
          const stepWidthPx = Math.abs(gait.feet.L.prev.x - gait.feet.R.prev.x);
          f.active.stepWidthCmAtIC = stepWidthPx * pxToCm;
        }

        const cTh = thresholds().crossover;
        const narrow = (typeof f.active.stepWidthCmAtIC === 'number') ? (f.active.stepWidthCmAtIC < cTh.narrowStepWidthCm) : false;

        if ((crossed || narrow) && shouldPersist(s => s.crossover === true || ((s.stepWidthCmAtIC ?? 999) < cTh.narrowStepWidthCm))) {
          addIssue('warning', `${side}: Crossover gait (midline/narrow)`, 'Crossover');
          f.active.tags.push('Crossover');
        }
      }
    }

    gait.icTimes.push(tIC);
    if (gait.icTimes.length > 12) gait.icTimes.shift();

    f.lastIC = tIC;
    f.lastIC_hipX = (hipMidX != null) ? hipMidX : null;

    setPhaseIndicator(1);
  }

  function onToeOff(side, tTO) {
    if (!isRecording) return;

    const f = gait.feet[side];
    if (!f.active || !f.active.inStance) return;

    f.active.tTO_ms = tTO;
    f.active.inStance = false;
    f.active.stanceTimeS = (tTO - f.active.tIC_ms) / 1000;

    f.active.kneeMidStanceDeg = computeKneeMidStance(f.active.samples, f.active.tIC_ms, tTO);

    const tPeak = f.active.grfProxy.tPeak;
    const ttpMs = (tPeak != null) ? Math.max(0, tPeak - f.active.tIC_ms) : null;
    f.active.grfTimeToPeakMs = ttpMs;

    const grfBW = mapDecelProxyToBW(f.active.grfProxy.peak);
    f.active.grfPeakBW = grfBW;
    f.active.landingQuality = classifyLanding(grfBW, ttpMs);

    if (viewMode() === 'frontal') {
      const c = thresholds().collapser;
      const drop = f.active.pelvicTiltMaxDeg || 0;
      const highNow = drop >= c.high;
      const modNow  = drop >= c.moderate;

      if (highNow && shouldPersist(s => (s.pelvicTiltMaxDeg ?? 0) >= c.high)) {
        addIssue('critical', `${side}: Collapser (pelvic drop ${drop.toFixed(1)}¬∞)`, 'Collapser');
        f.active.tags.push('Collapser');
        f.active.notes += 'Collapser pattern; ';
      } else if (modNow && shouldPersist(s => (s.pelvicTiltMaxDeg ?? 0) >= c.moderate)) {
        addIssue('warning', `${side}: Collapser tendency (pelvic drop ${drop.toFixed(1)}¬∞)`, 'Collapser');
        f.active.tags.push('Collapser');
        f.active.notes += 'Collapser tendency; ';
      }
    }

    const b = thresholds().bouncer;
    const voCm = (typeof f.active.voCmAtIC === 'number') ? f.active.voCmAtIC : 0;
    const voRatio = (typeof f.active.voRatioAtIC === 'number') ? f.active.voRatioAtIC : 0;

    if ((voCm > b.voCm || voRatio > b.voRatio) && shouldPersist(s => (s.voCmAtIC ?? 0) > b.voCm || (s.voRatioAtIC ?? 0) > b.voRatio)) {
      addIssue('warning', `${side}: Bouncer (VO ${voCm.toFixed(1)}cm)`, 'Bouncer');
      f.active.tags.push('Bouncer');
      f.active.notes += 'High VO; ';
    }

    if (typeof f.active.kneeMidStanceDeg === 'number' && f.active.kneeMidStanceDeg > 165) {
      addIssue('warning', `${side}: Low mid-stance knee flexion`);
      f.active.notes += 'Low mid-stance knee flexion; ';
    }
    if (f.active.landingQuality === 'Hard') {
      addIssue('warning', `${side}: Hard landing tendency (GRF proxy)`);
      f.active.notes += 'Hard landing tendency; ';
    }

    updateLastStepCards(f.active);
    finalizeStep(f.active);

    f.active = null;
    f.lastTO = tTO;

    setPhaseIndicator(3);
  }

  function computeKneeMidStance(samples, tIC, tTO) {
    if (!samples || !samples.length) return null;
    const target = tIC + 0.5 * (tTO - tIC);
    let best = null, bestDt = Infinity;
    for (const s of samples) {
      const dt = Math.abs(s.t - target);
      if (dt < bestDt) { bestDt = dt; best = s.kneeDeg; }
    }
    return (typeof best === 'number') ? best : null;
  }

  function updateLastStepCards(step) {
    if (step.side === 'L') {
      document.getElementById('kneeMSL').innerHTML = `${(step.kneeMidStanceDeg ?? 0).toFixed(0)}<span class="metric-unit">¬∞</span>`;
    } else {
      document.getElementById('kneeMSR').innerHTML = `${(step.kneeMidStanceDeg ?? 0).toFixed(0)}<span class="metric-unit">¬∞</span>`;
    }
    document.getElementById('grfPeak').innerHTML = `${(step.grfPeakBW ?? 0).toFixed(2)}<span class="metric-unit">BW</span>`;
    document.getElementById('grfTTP').innerHTML = `${(step.grfTimeToPeakMs ?? 0).toFixed(0)}<span class="metric-unit">ms</span>`;
  }

  // ============================================================
  // Deficiency sub-scores (0‚Äì100 each) + total score
  // ============================================================
  function clamp01(x) { return Math.max(0, Math.min(1, x)); }
  function clamp100(x) { return Math.max(0, Math.min(100, x)); }

  function computeDeficiencySubscores(step) {
    const th = thresholds();

    // Overstrider: 0 at <moderate, 100 at >=high (linear between)
    let over = 0;
    if (typeof step.overstrideFSR === 'number') {
      const fsr = step.overstrideFSR;
      const s = (fsr - th.overstride.moderate) / (th.overstride.high - th.overstride.moderate || 1);
      over = clamp100(100 * clamp01(s));
    }

    // Collapser: pelvic drop max
    let coll = 0;
    if (typeof step.pelvicTiltMaxDeg === 'number') {
      const d = step.pelvicTiltMaxDeg;
      const s = (d - th.collapser.moderate) / (th.collapser.high - th.collapser.moderate || 1);
      coll = clamp100(100 * clamp01(s));
    }

    // Bouncer: max of VO cm and VO ratio signals
    let bounce = 0;
    {
      const voCm = (typeof step.voCmAtIC === 'number') ? step.voCmAtIC : null;
      const voRatio = (typeof step.voRatioAtIC === 'number') ? step.voRatioAtIC : null;

      const s1 = (voCm != null)
        ? (voCm - th.bouncer.voCm) / (th.bouncer.voCm * 0.5 || 1)
        : -Infinity;

      const s2 = (voRatio != null)
        ? (voRatio - th.bouncer.voRatio) / (th.bouncer.voRatio * 0.5 || 1)
        : -Infinity;

      bounce = clamp100(100 * clamp01(Math.max(s1, s2, 0)));
    }

    // Crossover: binary midline crossing + narrow step width support
    let cross = 0;
    if (step.crossover === true) cross = 100;
    else if (typeof step.stepWidthCmAtIC === 'number' && step.stepWidthCmAtIC < th.crossover.narrowStepWidthCm) cross = 70;
    else cross = 0;

    return {
      collapser: coll,
      overstrider: over,
      bouncer: bounce,
      crossover: cross
    };
  }

  function computeDeficiencyScore(step) {
    // weighted total remains 0‚Äì100 for continuity (picker + XLSX)
    const subs = step.deficiencySubscores || computeDeficiencySubscores(step);
    const total =
      0.30 * subs.collapser +
      0.35 * subs.overstrider +
      0.20 * subs.bouncer +
      0.15 * subs.crossover;
    return clamp100(total);
  }

  function finalizeStep(step) {
    const row = {
      idx: gait.steps.length + 1,
      side: step.side,
      tIC_ms: step.tIC_ms,
      tTO_ms: step.tTO_ms,
      stanceTimeS: step.stanceTimeS,
      swingTimeS: step.swingTimeS,
      strideCm: step.strideCm,
      kneeMidStanceDeg: step.kneeMidStanceDeg,
      pelvicTiltMaxDeg: step.pelvicTiltMaxDeg,
      grfPeakBW: step.grfPeakBW,
      grfTimeToPeakMs: step.grfTimeToPeakMs,
      landingQuality: step.landingQuality,
      overstrideLevel: step.overstrideLevel,
      grfCurve: step.grfCurve || [],
      notes: (step.notes || '').trim(),
      overstrideFSR: step.overstrideFSR,
      crossover: step.crossover,
      stepWidthCmAtIC: step.stepWidthCmAtIC,
      voCmAtIC: step.voCmAtIC,
      voRatioAtIC: step.voRatioAtIC,
      tags: Array.isArray(step.tags) ? step.tags.slice() : []
    };

    // NEW: store subscores + total
    row.deficiencySubscores = computeDeficiencySubscores(row);
    row.deficiencyScore = computeDeficiencyScore(row);

    gait.steps.push(row);

    rebuildStepPicker();

    stepPicker.value = String(row.idx);
    renderSelectedGRFCurve();

    exportBtn.disabled = gait.steps.length === 0;
  }

  function findLastStepOfSide(side) {
    for (let i = gait.steps.length - 1; i >= 0; i--) {
      if (gait.steps[i].side === side) return gait.steps[i];
    }
    return null;
  }

  // ============================================================
  // Phase + cadence + rolling stats
  // ============================================================
  function updatePhaseUI(L_contact, R_contact) {
    let label = 'Standing', dot = 1;
    if (L_contact && R_contact) { label = 'Double Support'; dot = 2; }
    else if (L_contact && !R_contact) { label = 'Right Swing'; dot = 4; }
    else if (!L_contact && R_contact) { label = 'Left Swing'; dot = 4; }
    else if (!L_contact && !R_contact) { label = 'Flight / Both Swing'; dot = 4; }
    document.getElementById('gaitPhase').textContent = label;
    setPhaseIndicator(dot);
  }

  function updateCadenceUI() {
    const t = gait.icTimes;
    if (t.length < 4) return;
    const lastN = 8;
    const slice = t.slice(-lastN);

    const deltas = [];
    for (let i = 1; i < slice.length; i++) deltas.push((slice[i] - slice[i-1]) / 1000);
    const avg = deltas.reduce((a,b)=>a+b,0) / deltas.length;
    const cadence = avg > 0 ? Math.round(60 / avg) : 0;

    document.getElementById('cadence').innerHTML = `${cadence}<span class="metric-unit">steps/min</span>`;
    if (cadence > 0 && cadence < 160) addIssue('warning', 'Low cadence - consider increasing step rate');
  }

  function updateRollingUI() {
    const steps = gait.steps;
    if (!steps.length) return;
    const n = gait.recentWindow;
    const slice = steps.slice(-n);

    const nums = (k) => slice.map(s => s[k]).filter(v => typeof v === 'number' && isFinite(v));
    const mean = (arr) => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;

    const stanceAvg = mean(nums('stanceTimeS'));
    const swingAvg = mean(nums('swingTimeS'));
    const strideAvg = mean(nums('strideCm'));

    document.getElementById('stanceTime').innerHTML = `${stanceAvg.toFixed(2)}<span class="metric-unit">s</span>`;
    document.getElementById('swingTime').innerHTML = `${swingAvg.toFixed(2)}<span class="metric-unit">s</span>`;
    document.getElementById('strideLength').innerHTML = `${strideAvg.toFixed(0)}<span class="metric-unit">cm</span>`;
  }

  // ============================================================
  // VO + Pelvic + Frontal drift
  // ============================================================
  function updateVerticalOscillation(hipMidY, pxToCm) {
    const vo = gait.vo;
    const alpha = 0.02;
    if (vo.baselineY == null) vo.baselineY = hipMidY;
    vo.baselineY = (1 - alpha) * vo.baselineY + alpha * hipMidY;

    const devPx = Math.abs(hipMidY - vo.baselineY);
    vo.maxDevPx = Math.max(vo.maxDevPx, devPx);
    vo.windowFrames++;

    if (vo.windowFrames >= 30) {
      vo.lastVOcm = vo.maxDevPx * pxToCm;
      vo.maxDevPx = 0;
      vo.windowFrames = 0;
    }
    return vo.lastVOcm;
  }

  function computePelvicTiltDeg(hipL, hipR) {
    if (!hipL || !hipR) return 0;
    const dy = (hipR.y - hipL.y);
    const dx = (hipR.x - hipL.x) || 1;
    return Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);
  }

  function computeKneeMedialDriftProxyDeg(hipL, kneeL, ankleL, hipR, kneeR, ankleR) {
    const ang = (hip, knee, ankle) => {
      if (!hip || !knee || !ankle) return null;
      const ax = (hip.x - knee.x) * 1.5, ay = (hip.y - knee.y);
      const bx = (ankle.x - knee.x) * 1.5, by = (ankle.y - knee.y);
      const dot = ax*bx + ay*by;
      const na = Math.hypot(ax, ay) || 1;
      const nb = Math.hypot(bx, by) || 1;
      const cos = Math.max(-1, Math.min(1, dot/(na*nb)));
      return Math.acos(cos) * 180 / Math.PI;
    };

    const aL = ang(hipL, kneeL, ankleL);
    const aR = ang(hipR, kneeR, ankleR);

    const driftL = (aL != null) ? Math.max(0, 180 - aL) : null;
    const driftR = (aR != null) ? Math.max(0, 180 - aR) : null;

    const vals = [driftL, driftR].filter(v => typeof v === 'number');
    const max = vals.length ? Math.max(...vals) : 0;

    if (max > 18) addIssue('critical', 'Frontal: High knee medial drift (valgus proxy)');
    else if (max > 12) addIssue('warning', 'Frontal: Moderate knee medial drift (valgus proxy)');

    return max;
  }

  // ============================================================
  // GRF proxy
  // ============================================================
  function mapDecelProxyToBW(p) {
    const x = Math.max(0, Math.min(p, 20000));
    return 1.2 + 1.8 * (1 - Math.exp(-x / 6000));
  }

  function classifyLanding(grfBW, ttpMs) {
    if (ttpMs == null) return 'Moderate';
    if (grfBW >= 2.6 && ttpMs <= 70) return 'Hard';
    if (grfBW <= 2.0 && ttpMs >= 110) return 'Soft';
    return 'Moderate';
  }

  // ============================================================
  // Overstride risk (FSR-based)
  // ============================================================
  function computeOverstrideRisk_FSR(fsr) {
    if (typeof fsr !== 'number' || !isFinite(fsr)) return { level: 'Low', fsr: null };
    const th = thresholds().overstride;
    if (fsr >= th.high) return { level: 'High', fsr };
    if (fsr >= th.moderate) return { level: 'Moderate', fsr };
    return { level: 'Low', fsr };
  }

  // ============================================================
  // Geometry helpers
  // ============================================================
  function estimatePxToCm(nose, ankleL, ankleR, heightCm) {
    if (!heightCm || !nose || (!ankleL && !ankleR)) return null;
    const lowestAnkleY = Math.max(ankleL ? ankleL.y : 0, ankleR ? ankleR.y : 0);
    const bodyPx = Math.abs(lowestAnkleY - nose.y);
    if (bodyPx < 50) return null;
    return heightCm / bodyPx;
  }

  function midX(a, b) {
    if (a && b) return (a.x + b.x) / 2;
    if (a) return a.x;
    if (b) return b.x;
    return null;
  }
  function midY(a, b) {
    if (a && b) return (a.y + b.y) / 2;
    if (a) return a.y;
    if (b) return b.y;
    return null;
  }

  function calculateAngle(a, b, c) {
    const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
    let angle = Math.abs(radians * 180 / Math.PI);
    if (angle > 180) angle = 360 - angle;
    return angle;
  }

  // ============================================================
  // Issues list (adds tag label: Collapser / Overstrider / Bouncer / Crossover)
  // ============================================================
  function addIssue(severity, message, tagLabel) {
    const key = `${severity}:${message}`;
    if (detectedIssues.has(key)) return;

    detectedIssues.add(key);
    const issuesList = document.getElementById('issuesList');

    if (detectedIssues.size === 1) issuesList.innerHTML = '';

    const div = document.createElement('div');
    div.className = 'issue-item ' + severity;

    if (tagLabel) {
      div.textContent = message;
      const tag = document.createElement('span');
      tag.className = 'issue-tag';
      tag.textContent = tagLabel;
      div.appendChild(tag);
    } else {
      div.textContent = message;
    }

    issuesList.insertBefore(div, issuesList.firstChild);

    while (issuesList.children.length > 6) issuesList.removeChild(issuesList.lastChild);

    setTimeout(() => detectedIssues.delete(key), 6500);
  }

  // ============================================================
  // Recording (fixed: button always reflects state, stop is stable)
  // ============================================================
  function toggleRecording() {
    isRecording = !isRecording;
    setRecordingUI();

    if (isRecording) {
      resetGaitAll();
      exportBtn.disabled = true;
      setStatus('ready', 'üî¥ Recording per-step metrics‚Ä¶');
    } else {
      exportBtn.disabled = gait.steps.length === 0;
      setStatus('ready', `‚úì Recording stopped ‚Äî ${gait.steps.length} steps captured`);
      rebuildStepPicker();
      renderSelectedGRFCurve();
    }
  }

  // ============================================================
  // Snapshot PNG
  // ============================================================
  async function exportSnapshotPNG() {
    if (!(sourceMode === 'camera' || sourceMode === 'video')) {
      alert('No active source.');
      return;
    }
    const w = canvas.width || webcam.videoWidth;
    const h = canvas.height || webcam.videoHeight;
    if (!w || !h) { alert('Video not ready yet.'); return; }

    const out = document.createElement('canvas');
    out.width = w; out.height = h;
    const octx = out.getContext('2d');

    octx.drawImage(webcam, 0, 0, w, h);
    octx.drawImage(canvas, 0, 0, w, h);

    const filename = `gait_snapshot_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.png`;
    out.toBlob(async (blob) => {
      if (!blob) return alert('Snapshot failed');
      setStatus('ready', 'Saving snapshot‚Ä¶');
      await saveFile(blob, filename, 'image/png');
      setStatus('ready', '‚úì Snapshot exported (iPhone: Share ‚Üí Save to Files)');
    }, 'image/png');
  }

  // ============================================================
  // XLSX export (adds subscores columns, keeps existing)
  // ============================================================
  async function exportToXLSX() {
    if (!gait.steps.length) return alert('No steps to export. Record first.');

    const subject = {
      sex: subjectSexEl.value,
      age: parseFloat(subjectAgeEl.value || '0'),
      mass: parseFloat(subjectMassEl.value || '0'),
      height: parseFloat(subjectHeightEl.value || '0')
    };

    const filename = `gait_steps_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.xlsx`;
    const wb = XLSX.utils.book_new();

    const subjectSheetData = [
      ['Gait Biodynamics Lab - Per-Step Report'],
      ['Date', new Date().toLocaleString()],
      ['Source', sourceMode],
      ['View Mode', viewMode()],
      ['Sex', subject.sex],
      ['Age (years)', subject.age],
      ['Mass (kg)', subject.mass],
      ['Height (cm)', subject.height],
      ['Copyright', '¬© 2025 Ng Jun Wei. All rights reserved.'],
      ['Notes', 'Knee mid-stance = knee angle near 50% stance. GRF proxy curve = BW proxy over stance from ankle vertical decel. VO from hip-mid baseline filtered. Overstride uses FSR normalized by leg length px at IC. Collapser uses peak pelvic drop proxy during stance (frontal). Crossover uses midline crossing (frontal). Subscores are 0‚Äì100 each (Collapser/Overstrider/Bouncer/Crossover).']
    ];
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(subjectSheetData), 'Subject');

    const rows = gait.steps.map(s => {
      const subs = s.deficiencySubscores || computeDeficiencySubscores(s);
      return ({
        'Step #': s.idx,
        'Side': s.side,
        'IC Time (ms)': Math.round(s.tIC_ms),
        'TO Time (ms)': (typeof s.tTO_ms === 'number') ? Math.round(s.tTO_ms) : '',
        'Stance Time (s)': (typeof s.stanceTimeS === 'number') ? Number(s.stanceTimeS.toFixed(3)) : '',
        'Swing Time (s)': (typeof s.swingTimeS === 'number') ? Number(s.swingTimeS.toFixed(3)) : '',
        'Stride Length (cm)': (typeof s.strideCm === 'number') ? Number(s.strideCm.toFixed(1)) : '',
        'Knee Flexion Mid-Stance (¬∞)': (typeof s.kneeMidStanceDeg === 'number') ? Number(s.kneeMidStanceDeg.toFixed(1)) : '',
        'Pelvic Drop Max (¬∞ proxy)': (typeof s.pelvicTiltMaxDeg === 'number') ? Number(s.pelvicTiltMaxDeg.toFixed(2)) : '',
        'GRF Peak (BW, proxy)': (typeof s.grfPeakBW === 'number') ? Number(s.grfPeakBW.toFixed(2)) : '',
        'GRF Time-to-Peak (ms, proxy)': (typeof s.grfTimeToPeakMs === 'number') ? Number(s.grfTimeToPeakMs.toFixed(0)) : '',
        'Landing Quality': s.landingQuality || '',
        'Overstride Level (sagittal)': s.overstrideLevel || '',
        'Overstride FSR (leg-normalized)': (typeof s.overstrideFSR === 'number') ? Number(s.overstrideFSR.toFixed(3)) : '',
        'Crossover (midline)': (s.crossover === true) ? 'Yes' : (s.crossover === false ? 'No' : ''),
        'Step width at IC (cm)': (typeof s.stepWidthCmAtIC === 'number') ? Number(s.stepWidthCmAtIC.toFixed(1)) : '',
        'VO at IC (cm)': (typeof s.voCmAtIC === 'number') ? Number(s.voCmAtIC.toFixed(1)) : '',
        'VO ratio at IC': (typeof s.voRatioAtIC === 'number') ? Number(s.voRatioAtIC.toFixed(4)) : '',
        'Collapser Subscore (0-100)': Number(subs.collapser.toFixed(1)),
        'Overstrider Subscore (0-100)': Number(subs.overstrider.toFixed(1)),
        'Bouncer Subscore (0-100)': Number(subs.bouncer.toFixed(1)),
        'Crossover Subscore (0-100)': Number(subs.crossover.toFixed(1)),
        'Deficiency Score (0-100)': (typeof s.deficiencyScore === 'number') ? Number(s.deficiencyScore.toFixed(1)) : '',
        'Tags': Array.isArray(s.tags) ? s.tags.join(', ') : '',
        'Notes': s.notes || ''
      });
    });
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(rows), 'Steps');

    const curveRows = [];
    for (const s of gait.steps) {
      if (!s.grfCurve || !s.grfCurve.length) continue;
      for (const p of s.grfCurve) {
        curveRows.push({
          'Step #': s.idx,
          'Side': s.side,
          't_from_IC_ms': Math.round(p.tRelMs),
          'GRF_proxy_BW': Number(p.bw.toFixed(3))
        });
      }
    }
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(curveRows), 'GRF_Curves');

    const arrayBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([arrayBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

    setStatus('ready', 'Preparing XLSX‚Ä¶');
    await saveFile(blob, filename, blob.type);
    setStatus('ready', '‚úì XLSX exported (iPhone: Share ‚Üí Save to Files)');
  }

  async function saveFile(blob, filename, mime) {
    const canShare = !!(navigator.canShare && navigator.share);

    if (isIOS && canShare) {
      try {
        const file = new File([blob], filename, { type: mime });
        if (navigator.canShare({ files: [file] })) {
          await navigator.share({ files: [file], title: filename, text: 'Exported from Gait Biodynamics Lab' });
          return true;
        }
      } catch (_) {}
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(() => URL.revokeObjectURL(url), 1500);
    return true;
  }

  // ============================================================
  // Video seek + frame stepping
  // ============================================================
  function formatTime(sec) {
    if (!isFinite(sec)) return '0.000';
    return sec.toFixed(3);
  }

  function updateSeekUI() {
    if (sourceMode !== 'video') return;
    const dur = webcam.duration || 0;
    const t = webcam.currentTime || 0;
    const max = 1000;
    const v = dur > 0 ? Math.round((t / dur) * max) : 0;
    seekBar.value = String(v);
    timeLabel.textContent = `${formatTime(t)} / ${formatTime(dur)}`;
  }

  function seekToBarValue() {
    const dur = webcam.duration || 0;
    if (dur <= 0) return;
    const v = Number(seekBar.value || 0);
    const t = (v / 1000) * dur;
    webcam.currentTime = Math.min(dur, Math.max(0, t));
    updateSeekUI();
  }

  function frameStep(deltaFrames) {
    if (sourceMode !== 'video') return;
    if (!webcam.paused) {
      webcam.pause();
      playPauseBtn.textContent = 'Play';
      stopLoops();
    }
    const assumedFps = Math.max(10, Math.min(1000, Number(assumedFpsEl.value || 240)));
    const stepFrames = Math.max(1, Number(frameStepModeEl.value || 1));
    const dt = (deltaFrames * stepFrames) / assumedFps;
    const dur = webcam.duration || 0;
    const next = Math.min(dur || Infinity, Math.max(0, (webcam.currentTime || 0) + dt));
    webcam.currentTime = next;
    updateSeekUI();
    resizeCanvasToVideo();
    loopPose(webcam.currentTime * 1000);
  }

  function skipSeconds(ds) {
    if (sourceMode !== 'video') return;
    if (!webcam.paused) {
      webcam.pause();
      playPauseBtn.textContent = 'Play';
      stopLoops();
    }
    const dur = webcam.duration || 0;
    const next = Math.min(dur || Infinity, Math.max(0, (webcam.currentTime || 0) + ds));
    webcam.currentTime = next;
    updateSeekUI();
    resizeCanvasToVideo();
    loopPose(webcam.currentTime * 1000);
  }

  // ============================================================
  // Events
  // ============================================================
  startCamBtn.addEventListener('click', startCamera);

  loadVideoBtn.addEventListener('click', () => videoFile.click());
  videoFile.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    await loadVideoFile(file);
    videoFile.value = '';
  });

  playPauseBtn.addEventListener('click', togglePlayPause);
  stopBtn.addEventListener('click', stopAll);

  recordBtn.addEventListener('click', toggleRecording);
  exportBtn.addEventListener('click', exportToXLSX);
  snapshotBtn.addEventListener('click', exportSnapshotPNG);

  viewModeEl.addEventListener('change', syncModeUI);

  seekBar.addEventListener('input', () => { if (sourceMode === 'video') seekToBarValue(); });
  webcam.addEventListener('timeupdate', () => updateSeekUI());
  webcam.addEventListener('loadedmetadata', () => { updateSeekUI(); resizeCanvasToVideo(); });
  webcam.addEventListener('durationchange', () => updateSeekUI());

  stepBackBtn.addEventListener('click', () => frameStep(-1));
  stepFwdBtn.addEventListener('click', () => frameStep(+1));
  skipBackBtn.addEventListener('click', () => skipSeconds(-0.1));
  skipFwdBtn.addEventListener('click', () => skipSeconds(+0.1));

  stepPicker.addEventListener('change', renderSelectedGRFCurve);

  // ============================================================
  // Boot
  // ============================================================
  (async function boot() {
    try {
      setStatus('loading', '<span class="loading-spinner"></span> Loading AI model‚Ä¶');
      await initModel();

      stopBtn.disabled = true;
      recordBtn.disabled = true;
      exportBtn.disabled = true;
      snapshotBtn.disabled = true;
      playPauseBtn.disabled = true;

      isRecording = false;
      setRecordingUI();
    } catch (e) {
      setStatus('error', '‚úó Init Error: ' + (e?.message || e));
      console.error(e);
    }
  })();
</script>
</body>
</html>
