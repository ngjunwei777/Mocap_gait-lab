<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gait Biodynamics Lab - Treadmill Running Analysis</title>
  <meta name="description" content="AI-powered treadmill running gait analysis by Ng Jun Wei. Real-time pose estimation, running gait metrics, and CSV export for biomechanics research.">

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 { text-align: center; color: #667eea; margin-bottom: 10px; font-size: 2.5em; }
    .subtitle { text-align: center; color: #666; margin-bottom: 30px; }
    .main-content {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 30px;
      margin-bottom: 20px;
    }
    @media (max-width: 968px) {
      .main-content { grid-template-columns: 1fr; }
      h1 { font-size: 1.8em; }
    }
    .video-section { position: relative; }
    #videoContainer {
      position: relative;
      width: 100%;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #webcam { width: 100%; display: block; }
    #canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
    }
    .fps-indicator {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      padding: 8px 15px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 14px;
      z-index: 10;
    }
    .confidence-indicator {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 8px 15px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      z-index: 10;
    }
    .controls {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    button {
      flex: 1;
      min-width: 150px;
      padding: 15px 25px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    #startBtn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
    #startBtn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4); }
    #stopBtn { background: #e74c3c; color: white; }
    #stopBtn:hover:not(:disabled) { background: #c0392b; transform: translateY(-2px); }
    #recordBtn { background: #27ae60; color: white; }
    #recordBtn:hover:not(:disabled) { background: #229954; }
    #recordBtn.recording { background: #e74c3c; animation: pulse 1.5s infinite; }
    #exportBtn { background: #3498db; color: white; }
    #exportBtn:hover:not(:disabled) { background: #2980b9; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

    .analysis-panel {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 20px;
      height: fit-content;
    }
    .metrics {
      display: grid;
      gap: 15px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    .metric-card {
      background: white;
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .metric-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
    }
    .metric-value { font-size: 20px; font-weight: bold; color: #333; }
    .metric-unit { font-size: 14px; color: #999; margin-left: 5px; }

    .status { padding: 10px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-weight: 600; }
    .status.loading { background: #fff3cd; color: #856404; }
    .status.ready { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }

    .gait-phase {
      background: white;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .phase-indicator { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
    .phase-dot {
      width: 40px; height: 40px;
      border-radius: 50%;
      background: #e0e0e0;
      display: flex; align-items: center; justify-content: center;
      font-size: 10px; font-weight: bold;
      color: #999;
      transition: all 0.3s;
    }
    .phase-dot.active { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; transform: scale(1.2); }

    .issues-list {
      background: white;
      padding: 15px;
      border-radius: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    .issue-item { padding: 10px; margin-bottom: 8px; border-radius: 5px; font-size: 14px; }
    .issue-item.warning { background: #fff3cd; border-left: 3px solid #ffc107; }
    .issue-item.critical { background: #f8d7da; border-left: 3px solid #dc3545; }

    .loading-spinner {
      display: inline-block;
      width: 20px; height: 20px;
      border: 3px solid rgba(102, 126, 234, 0.3);
      border-radius: 50%;
      border-top-color: #667eea;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .charts-section {
      margin-top: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 15px;
    }
    .charts-section h3 { color: #667eea; margin-bottom: 15px; }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .chart-container canvas { max-height: 280px; }

    .info-section {
      margin-top: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 15px;
    }
    .info-section h3 { color: #667eea; margin-bottom: 15px; }
    .info-section ul { margin-left: 20px; line-height: 1.8; }

    .github-footer {
      text-align: center;
      margin-top: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 15px;
    }
    .github-footer a { color: #667eea; text-decoration: none; font-weight: 600; }
    .github-footer a:hover { text-decoration: underline; }
  </style>
</head>

<body>
  <div class="container">
    <h1>Jun Wei's Gait Lab</h1>
    <p class="subtitle">Treadmill Running Gait Analysis (Sagittal + Frontal)</p>

    <div id="status" class="status loading">
      <span class="loading-spinner"></span> Initializing AI Model...
    </div>

    <!-- Subject info -->
    <div class="info-section">
      <h3>ðŸ‘¤ Subject Information</h3>
      <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Sex:</label>
          <select id="subjectSex" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
            <option value="male">Male</option>
            <option value="female">Female</option>
          </select>
        </div>
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Age (years):</label>
          <input type="number" id="subjectAge" min="1" max="120" value="30" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
        </div>
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Mass (kg):</label>
          <input type="number" id="subjectMass" min="20" max="300" value="70" step="0.1" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
        </div>
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Height (cm):</label>
          <input type="number" id="subjectHeight" min="100" max="250" value="170" step="0.1" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
        </div>
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <div id="videoContainer">
          <div class="fps-indicator" id="fpsDisplay">FPS: 0</div>
          <div class="confidence-indicator" id="confDisplay">Conf: 0%</div>
          <video id="webcam" autoplay playsinline muted></video>
          <canvas id="canvas"></canvas>
        </div>
        <div class="controls">
          <button id="startBtn" disabled>Start Camera</button>
          <button id="stopBtn" disabled>Stop Camera</button>
          <button id="recordBtn" disabled>Start Recording</button>
          <button id="exportBtn" disabled>Export CSV</button>
        </div>
      </div>

      <div class="analysis-panel">
        <h3 style="margin-bottom: 15px; color: #667eea;">Real-Time Analysis</h3>

        <div class="gait-phase">
          <div class="metric-label">Current Gait Phase (Running)</div>
          <div class="metric-value" id="gaitPhase">Standing</div>
          <div class="phase-indicator">
            <div class="phase-dot" id="phase1">LC</div>
            <div class="phase-dot" id="phase2">DC</div>
            <div class="phase-dot" id="phase3">RC</div>
            <div class="phase-dot" id="phase4">FL</div>
          </div>
          <div style="font-size: 10px; color: #999; margin-top: 10px; text-align: center;">
            LC: Left Contact | DC: Double Contact | RC: Right Contact | FL: Flight
          </div>
        </div>

        <div class="metrics">
          <div class="metric-card">
            <div class="metric-label">Cadence</div>
            <div class="metric-value" id="cadence">0<span class="metric-unit">steps/min</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Stride Length</div>
            <div class="metric-value" id="strideLength">0<span class="metric-unit">cm</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">GRF (Left)</div>
            <div class="metric-value" id="grfLeft">0<span class="metric-unit">N</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">GRF (Right)</div>
            <div class="metric-value" id="grfRight">0<span class="metric-unit">N</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Knee Flexion (L)</div>
            <div class="metric-value" id="kneeAngle">0<span class="metric-unit">Â°</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Knee Flexion (R)</div>
            <div class="metric-value" id="kneeAngleRight">0<span class="metric-unit">Â°</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Hip Drop (Sagittal)</div>
            <div class="metric-value" id="hipDrop">0<span class="metric-unit">Â°</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Overstride Risk</div>
            <div class="metric-value" id="overstride">Low</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Vertical Oscillation</div>
            <div class="metric-value" id="verticalOscillation">0<span class="metric-unit">cm</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Foot Strike Pattern</div>
            <div class="metric-value" id="footStrike">Unknown</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Stance/Flight Ratio</div>
            <div class="metric-value" id="stanceFlightRatio">0</div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Ground Contact Time</div>
            <div class="metric-value" id="contactTime">0<span class="metric-unit">ms</span></div>
          </div>
          <!-- New frontal-plane metrics -->
          <div class="metric-card">
            <div class="metric-label">Pelvic Drop (Frontal)</div>
            <div class="metric-value" id="pelvicDropFrontal">0<span class="metric-unit">Â°</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Knee FPPA (L)</div>
            <div class="metric-value" id="kneeFpaaLeft">0<span class="metric-unit">Â°</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Knee FPPA (R)</div>
            <div class="metric-value" id="kneeFpaaRight">0<span class="metric-unit">Â°</span></div>
          </div>
          <div class="metric-card">
            <div class="metric-label">Step Width</div>
            <div class="metric-value" id="stepWidth">0<span class="metric-unit">cm</span></div>
          </div>
        </div>

        <div style="margin-top: 20px;">
          <div class="metric-label">Detected Issues</div>
          <div class="issues-list" id="issuesList">
            <div style="text-align: center; color: #999; padding: 20px;">No issues detected yet</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Charts -->
    <div class="charts-section" id="chartsSection">
      <h3>ðŸ“Š Gait Analysis Charts</h3>
      <div class="chart-container"><canvas id="kneeFlexionChart"></canvas></div>
      <div class="chart-container"><canvas id="cadenceChart"></canvas></div>
      <div class="chart-container"><canvas id="hipDropChart"></canvas></div>
      <div class="chart-container"><canvas id="vertOscChart"></canvas></div>
      <div class="chart-container"><canvas id="contactChart"></canvas></div>
      <div class="chart-container"><canvas id="frontalChart"></canvas></div>
    </div>

    <div class="info-section">
      <h3>ðŸ“‹ How to Use (Treadmill)</h3>
      <ul>
        <li>Click <strong>"Start Camera"</strong> and allow camera permission (rear camera on mobile recommended).</li>
        <li>For sagittal analysis, place the camera side-on; for frontal analysis, face the treadmill frontally with full body visible.</li>
        <li>Run at a steady pace for at least 20â€“30 seconds to stabilize metrics.</li>
        <li>Click <strong>"Start Recording"</strong> to log gait metrics; stop when enough data are collected.</li>
        <li>Click <strong>"Export CSV"</strong> to download full time-series and summary statistics.</li>
      </ul>
    </div>

    <div class="github-footer">
      <p>ðŸš€ <strong>Gait Analysis System</strong> - Educational Research Tool</p>
      <p style="margin-top: 10px;">Built with TensorFlow.js MoveNet and Chart.js.[web:4][web:16]</p>
      <p style="margin-top: 10px; font-size: 14px; color: #666;">
        For educational and research purposes only. Not a medical device.[web:32]
      </p>
    </div>
  </div>

  <script>
    // =========================
    // Globals
    // =========================
    let detector;
    let webcam;
    let canvas;
    let ctx;
    let animationId;
    let isRunning = false;
    let isRecording = false;

    let recordedData = [];
    let stepHistory = [];
    let kneeAngles = [];
    let kneeAnglesRight = [];
    let comHeights = [];
    let contactDurations = [];
    let detectedIssues = new Set();
    let lastStepTime = 0;
    let currentPhase = 'standing';
    let sessionStartTime = 0;
    let lastPhase = 'standing';
    let lastPhaseChangeTime = 0;

    let subjectData = { sex: 'male', age: 30, mass: 70, height: 170 };

    let segmentIssues = {
      leftUpperLeg: false, rightUpperLeg: false,
      leftLowerLeg: false, rightLowerLeg: false,
      leftFoot: false, rightFoot: false,
      hip: false
    };

    // FPS
    let fps = 0;
    let frameCount = 0;
    let fpsUpdateTime = 0;

    // Chart data
    let chartData = {
      timestamps: [],
      kneeFlexionLeft: [],
      kneeFlexionRight: [],
      cadence: [],
      hipDrop: [],
      verticalOsc: [],
      contactTime: [],
      pelvicDropFrontal: [],
      kneeFpaaLeft: [],
      kneeFpaaRight: []
    };

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordBtn = document.getElementById('recordBtn');
    const exportBtn = document.getElementById('exportBtn');
    const statusDiv = document.getElementById('status');

    let kneeChart, cadenceChart, hipChart, vertOscChart, contactChart, frontalChart;

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

    // =========================
    // Charts
    // =========================
    function initCharts() {
      const commonOptions = {
        responsive: true,
        maintainAspectRatio: true,
        animation: false,
        scales: {
          x: { display: true, title: { display: true, text: 'Time (s)' } },
          y: { display: true, beginAtZero: false }
        },
        plugins: { legend: { display: true } }
      };

      kneeChart = new Chart(document.getElementById('kneeFlexionChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Left Knee Flexion (Â°)',
            data: [],
            borderColor: '#667eea',
            backgroundColor: 'rgba(102, 126, 234, 0.1)',
            tension: 0.4
          }, {
            label: 'Right Knee Flexion (Â°)',
            data: [],
            borderColor: '#764ba2',
            backgroundColor: 'rgba(118, 75, 162, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'Angle (Â°)' }, suggestedMin: 120, suggestedMax: 180 }
          }
        }
      });

      cadenceChart = new Chart(document.getElementById('cadenceChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Cadence (steps/min)',
            data: [],
            borderColor: '#27ae60',
            backgroundColor: 'rgba(39, 174, 96, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'Steps/min' }, suggestedMin: 140, suggestedMax: 200 }
          }
        }
      });

      hipChart = new Chart(document.getElementById('hipDropChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Hip Drop (Sagittal, Â°)',
            data: [],
            borderColor: '#e74c3c',
            backgroundColor: 'rgba(231, 76, 60, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'Hip Drop (Â°)' }, suggestedMin: 0, suggestedMax: 15 }
          }
        }
      });

      vertOscChart = new Chart(document.getElementById('vertOscChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Vertical Oscillation (cm)',
            data: [],
            borderColor: '#f39c12',
            backgroundColor: 'rgba(243, 156, 18, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'Oscillation (cm)' }, suggestedMin: 0, suggestedMax: 10 }
          }
        }
      });

      contactChart = new Chart(document.getElementById('contactChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Ground Contact Time (ms)',
            data: [],
            borderColor: '#16a085',
            backgroundColor: 'rgba(22, 160, 133, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'Contact Time (ms)' }, suggestedMin: 150, suggestedMax: 400 }
          }
        }
      });

      frontalChart = new Chart(document.getElementById('frontalChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Pelvic Drop (Frontal, Â°)',
              data: [],
              borderColor: '#e67e22',
              backgroundColor: 'rgba(230, 126, 34, 0.1)',
              tension: 0.4
            },
            {
              label: 'Knee FPPA Left (Â°)',
              data: [],
              borderColor: '#c0392b',
              backgroundColor: 'rgba(192, 57, 43, 0.1)',
              tension: 0.4
            },
            {
              label: 'Knee FPPA Right (Â°)',
              data: [],
              borderColor: '#2980b9',
              backgroundColor: 'rgba(41, 128, 185, 0.1)',
              tension: 0.4
            }
          ]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'Angle (Â°)' }, beginAtZero: false }
          }
        }
      });
    }

    function updateCharts() {
      if (!isRecording || chartData.timestamps.length === 0) return;

      const maxPoints = 100;
      const startIdx = Math.max(0, chartData.timestamps.length - maxPoints);
      const labels = chartData.timestamps.slice(startIdx);

      kneeChart.data.labels = labels;
      kneeChart.data.datasets[0].data = chartData.kneeFlexionLeft.slice(startIdx);
      kneeChart.data.datasets[1].data = chartData.kneeFlexionRight.slice(startIdx);
      kneeChart.update('none');

      cadenceChart.data.labels = labels;
      cadenceChart.data.datasets[0].data = chartData.cadence.slice(startIdx);
      cadenceChart.update('none');

      hipChart.data.labels = labels;
      hipChart.data.datasets[0].data = chartData.hipDrop.slice(startIdx);
      hipChart.update('none');

      vertOscChart.data.labels = labels;
      vertOscChart.data.datasets[0].data = chartData.verticalOsc.slice(startIdx);
      vertOscChart.update('none');

      contactChart.data.labels = labels;
      contactChart.data.datasets[0].data = chartData.contactTime.slice(startIdx);
      contactChart.update('none');

      frontalChart.data.labels = labels;
      frontalChart.data.datasets[0].data = chartData.pelvicDropFrontal.slice(startIdx);
      frontalChart.data.datasets[1].data = chartData.kneeFpaaLeft.slice(startIdx);
      frontalChart.data.datasets[2].data = chartData.kneeFpaaRight.slice(startIdx);
      frontalChart.update('none');
    }

    // =========================
    // TFJS backend
    // =========================
    async function initTFBackend() {
      await tf.ready();
      const preferredBackends = (isIOS || isSafari) ? ['webgl', 'cpu'] : ['webgpu', 'webgl', 'cpu'];
      let ok = false;
      for (const b of preferredBackends) {
        try {
          await tf.setBackend(b);
          await tf.ready();
          ok = true;
          break;
        } catch (e) {}
      }
      if (!ok) throw new Error('No TFJS backend could be initialized.');
      return tf.getBackend();
    }

    async function init() {
      try {
        statusDiv.className = 'status loading';
        statusDiv.innerHTML = '<span class="loading-spinner"></span> Loading TensorFlow backend...';

        const backend = await initTFBackend();

        statusDiv.className = 'status loading';
        statusDiv.innerHTML = '<span class="loading-spinner"></span> Loading MoveNet model...';

        const modelType = (isIOS || isSafari)
          ? poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
          : poseDetection.movenet.modelType.SINGLEPOSE_THUNDER;

        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          {
            modelType,
            enableTracking: true,
            trackerType: poseDetection.TrackerType.BoundingBox
          }
        );

        initCharts();

        statusDiv.className = 'status ready';
        statusDiv.innerHTML = 'âœ“ AI Model Ready (backend: ' + backend + ') - Click "Start Camera" to begin';
        startBtn.disabled = false;
      } catch (error) {
        statusDiv.className = 'status error';
        statusDiv.innerHTML = 'âœ— Error loading model: ' + (error?.message || error);
        console.error('Initialization error:', error);
      }
    }

    // =========================
    // Camera
    // =========================
    async function startCamera() {
      try {
        webcam = document.getElementById('webcam');
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');

        webcam.muted = true;
        webcam.playsInline = true;
        webcam.setAttribute('playsinline', '');
        webcam.setAttribute('muted', '');
        webcam.setAttribute('autoplay', '');

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('getUserMedia not supported in this browser.');
        }

        const tryConstraints = [
          {
            video: {
              facingMode: { ideal: 'environment' },
              width: { ideal: 1920 },
              height: { ideal: 1080 },
              frameRate: { ideal: 120 }
            }
          },
          {
            video: {
              facingMode: { ideal: 'environment' },
              width: { ideal: 1280 },
              height: { ideal: 720 },
              frameRate: { ideal: 60 }
            }
          },
          { video: { facingMode: 'environment' } }
        ];

        let stream = null;
        let lastErr = null;
        for (const c of tryConstraints) {
          try {
            stream = await navigator.mediaDevices.getUserMedia(c);
            break;
          } catch (e) {
            lastErr = e;
          }
        }
        if (!stream) throw lastErr || new Error('Unable to access camera.');

        webcam.srcObject = stream;

        await new Promise((resolve) => {
          webcam.onloadeddata = () => resolve();
        });

        await webcam.play();

        canvas.width = webcam.videoWidth || 640;
        canvas.height = webcam.videoHeight || 480;

        isRunning = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        recordBtn.disabled = false;

        statusDiv.className = 'status ready';
        statusDiv.innerHTML = 'ðŸŽ¥ Camera Active - Ready to Analyze';

        fpsUpdateTime = performance.now();
        detectPose();

        const track = stream.getVideoTracks()[0];
        const settings = track.getSettings ? track.getSettings() : {};
        const gotFps = settings.frameRate ? Math.round(settings.frameRate) : '?';
        document.getElementById('fpsDisplay').textContent = 'FPS: 0 (Cam: ' + gotFps + ')';
      } catch (error) {
        statusDiv.className = 'status error';
        statusDiv.innerHTML = 'âœ— Camera Error: ' + (error?.message || error);
        console.error('Camera error:', error);
      }
    }

    function stopCamera() {
      if (webcam && webcam.srcObject) {
        webcam.srcObject.getTracks().forEach(track => track.stop());
        webcam.srcObject = null;
      }
      if (animationId) cancelAnimationFrame(animationId);

      isRunning = false;

      if (isRecording) toggleRecording();

      startBtn.disabled = false;
      stopBtn.disabled = true;
      recordBtn.disabled = true;

      if (ctx && canvas) ctx.clearRect(0, 0, canvas.width, canvas.height);

      statusDiv.className = 'status';
      statusDiv.innerHTML = 'Camera Stopped - Click "Start Camera" to resume';
      document.getElementById('fpsDisplay').textContent = 'FPS: 0';
    }

    // =========================
    // Pose loop
    // =========================
    async function detectPose() {
      if (!isRunning) return;

      const currentTime = performance.now();
      frameCount++;
      if (currentTime - fpsUpdateTime >= 1000) {
        fps = Math.round(frameCount * 1000 / (currentTime - fpsUpdateTime));
        document.getElementById('fpsDisplay').textContent = 'FPS: ' + fps;
        frameCount = 0;
        fpsUpdateTime = currentTime;
      }

      try {
        const poses = await detector.estimatePoses(webcam);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (poses.length > 0) {
          const pose = poses[0];
          const keypoints = pose.keypoints;

          drawSkeleton(keypoints);
          analyzeGait(keypoints, currentTime);
        }
      } catch (error) {
        console.error('Pose detection error:', error);
      }

      animationId = requestAnimationFrame(detectPose);
    }

    function drawSkeleton(keypoints) {
      segmentIssues = {
        leftUpperLeg: false, rightUpperLeg: false,
        leftLowerLeg: false, rightLowerLeg: false,
        leftFoot: false, rightFoot: false,
        hip: false
      };

      const connections = [
        { points: [5, 7], color: '#3498db', segment: null },
        { points: [7, 9], color: '#3498db', segment: null },
        { points: [5, 11], color: '#3498db', segment: null },
        { points: [11, 13], color: '#3498db', segment: 'leftUpperLeg' },
        { points: [13, 15], color: '#3498db', segment: 'leftLowerLeg' },

        { points: [6, 8], color: '#2ecc71', segment: null },
        { points: [8, 10], color: '#2ecc71', segment: null },
        { points: [6, 12], color: '#2ecc71', segment: null },
        { points: [12, 14], color: '#2ecc71', segment: 'rightUpperLeg' },
        { points: [14, 16], color: '#2ecc71', segment: 'rightLowerLeg' },

        { points: [5, 6], color: '#9b59b6', segment: null },
        { points: [11, 12], color: '#9b59b6', segment: 'hip' }
      ];

      ctx.lineWidth = 5;

      connections.forEach(conn => {
        const [i, j] = conn.points;
        const kp1 = keypoints[i];
        const kp2 = keypoints[j];

        if (kp1 && kp2 && kp1.score > 0.3 && kp2.score > 0.3) {
          let strokeColor = conn.color;
          if (conn.segment && segmentIssues[conn.segment]) strokeColor = '#e74c3c';
          ctx.strokeStyle = strokeColor;
          ctx.beginPath();
          ctx.moveTo(kp1.x, kp1.y);
          ctx.lineTo(kp2.x, kp2.y);
          ctx.stroke();
        }
      });

      keypoints.forEach((kp, idx) => {
        if (kp.score > 0.3) {
          ctx.beginPath();
          ctx.arc(kp.x, kp.y, 8, 0, 2 * Math.PI);

          if ([5, 7, 9, 11, 13, 15].includes(idx)) ctx.fillStyle = '#3498db';
          else if ([6, 8, 10, 12, 14, 16].includes(idx)) ctx.fillStyle = '#2ecc71';
          else ctx.fillStyle = '#9b59b6';

          ctx.fill();
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });
    }

    // =========================
    // Gait analysis
    // =========================
    function getConfidenceLevel(keypoints, indices) {
      const scores = indices.map(i => keypoints[i]?.score || 0);
      const avg = scores.reduce((a,b) => a + b, 0) / scores.length;
      return Math.round(avg * 100);
    }

    function analyzeGait(keypoints, timestamp) {
      const kpMap = {};
      keypoints.forEach((kp, i) => kpMap[i] = kp);

      subjectData.sex = document.getElementById('subjectSex').value;
      subjectData.age = parseFloat(document.getElementById('subjectAge').value);
      subjectData.mass = parseFloat(document.getElementById('subjectMass').value);
      subjectData.height = parseFloat(document.getElementById('subjectHeight').value);

      const conf = getConfidenceLevel(keypoints, [0,5,6,11,12,13,14,15,16]);
      document.getElementById('confDisplay').textContent = 'Conf: ' + conf + '%';
      if (conf < 60) {
        addIssue('warning', 'Low tracking confidence (' + conf + '%)');
      }

      let currentData = {
        timestamp: isRecording ? ((timestamp - sessionStartTime) / 1000).toFixed(2) : 0,
        kneeFlexionLeft: 0,
        kneeFlexionRight: 0,
        hipDrop: 0,
        cadence: 0,
        grfLeft: 0,
        grfRight: 0,
        overstride: 'Low',
        verticalOsc: 0,
        contactTime: 0,
        stanceFlightRatio: 0,
        footStrike: 'Unknown',
        gaitPhase: currentPhase,
        pelvicDropFrontal: 0,
        kneeFpaaLeft: 0,
        kneeFpaaRight: 0,
        stepWidth: 0,
        issues: []
      };

      const grfData = calculateGroundReactionForce(subjectData);
      currentData.grfLeft = grfData.left;
      currentData.grfRight = grfData.right;
      document.getElementById('grfLeft').innerHTML = Math.round(grfData.left) + '<span class="metric-unit">N</span>';
      document.getElementById('grfRight').innerHTML = Math.round(grfData.right) + '<span class="metric-unit">N</span>';

      // Left knee flexion
      if (kpMap[11] && kpMap[13] && kpMap[15]) {
        const angle = calculateAngle(kpMap[11], kpMap[13], kpMap[15]);
        kneeAngles.push(angle);
        if (kneeAngles.length > 30) kneeAngles.shift();

        document.getElementById('kneeAngle').innerHTML = Math.round(angle) + '<span class="metric-unit">Â°</span>';
        currentData.kneeFlexionLeft = Math.round(angle);

        if (angle > 165) {
          const issue = 'Insufficient left knee flexion';
          addIssue('warning', issue);
          currentData.issues.push(issue);
          segmentIssues.leftUpperLeg = true;
          segmentIssues.leftLowerLeg = true;
        }
      }

      // Right knee flexion
      if (kpMap[12] && kpMap[14] && kpMap[16]) {
        const angle = calculateAngle(kpMap[12], kpMap[14], kpMap[16]);
        kneeAnglesRight.push(angle);
        if (kneeAnglesRight.length > 30) kneeAnglesRight.shift();

        document.getElementById('kneeAngleRight').innerHTML = Math.round(angle) + '<span class="metric-unit">Â°</span>';
        currentData.kneeFlexionRight = Math.round(angle);

        if (angle > 165) {
          const issue = 'Insufficient right knee flexion';
          addIssue('warning', issue);
          currentData.issues.push(issue);
          segmentIssues.rightUpperLeg = true;
          segmentIssues.rightLowerLeg = true;
        }
      }

      // Hip drop (sagittal approximation)
      if (kpMap[11] && kpMap[12]) {
        const hipDrop = Math.abs(kpMap[11].y - kpMap[12].y);
        const hipDropAngle = Math.atan2(hipDrop, Math.abs(kpMap[11].x - kpMap[12].x) || 1) * 180 / Math.PI;

        document.getElementById('hipDrop').innerHTML = hipDropAngle.toFixed(1) + '<span class="metric-unit">Â°</span>';
        currentData.hipDrop = parseFloat(hipDropAngle.toFixed(1));

        if (hipDropAngle > 8) {
          const issue = 'Excessive hip drop (sagittal proxy)';
          addIssue('critical', issue);
          currentData.issues.push(issue);
          segmentIssues.hip = true;
        }
      }

      // Gait phase / contact time / stance-flight
      const phaseInfo = detectContactPhase(kpMap);
      currentData.gaitPhase = phaseInfo.phase;
      currentData.contactTime = phaseInfo.contactTime;
      currentData.stanceFlightRatio = phaseInfo.stanceFlightRatio;
      if (phaseInfo.contactTime > 0) {
        document.getElementById('contactTime').innerHTML =
          Math.round(phaseInfo.contactTime) + '<span class="metric-unit">ms</span>';
      }
      document.getElementById('stanceFlightRatio').textContent = phaseInfo.stanceFlightRatio.toFixed(2);

      // Cadence
      const nowMs = Date.now();
      const cadenceVal = computeCadence(nowMs);
      currentData.cadence = cadenceVal;
      if (cadenceVal > 0) {
        document.getElementById('cadence').innerHTML =
          cadenceVal + '<span class="metric-unit">steps/min</span>';
        if (cadenceVal < 160) {
          addIssue('warning', 'Low cadence - consider increasing step rate');
          currentData.issues.push('Low cadence');
        }
      }

      // Stride length
      const strideLen = calculateStrideLength(kpMap);
      if (strideLen > 0) {
        currentData.strideLength = strideLen;
        document.getElementById('strideLength').innerHTML =
          strideLen.toFixed(0) + '<span class="metric-unit">cm</span>';
      }

      // Overstride
      if (kpMap[11] && kpMap[15] && kpMap[0]) {
        const hipAnkleDistance = Math.abs(kpMap[15].x - kpMap[11].x);
        const bodyHeightPixels = Math.abs(kpMap[0].y - kpMap[15].y) || 1;
        const overstrideRatio = hipAnkleDistance / bodyHeightPixels;

        if (overstrideRatio > 0.3) {
          currentData.overstride = 'High';
          document.getElementById('overstride').textContent = 'High';
          const issue = 'Overstriding detected';
          addIssue('critical', issue);
          currentData.issues.push(issue);
          segmentIssues.leftLowerLeg = true;
          segmentIssues.leftFoot = true;
        } else if (overstrideRatio > 0.2) {
          currentData.overstride = 'Moderate';
          document.getElementById('overstride').textContent = 'Moderate';
        } else {
          currentData.overstride = 'Low';
          document.getElementById('overstride').textContent = 'Low';
        }
      }

      // Vertical oscillation
      const vertOsc = calculateVerticalOscillation(kpMap);
      if (vertOsc > 0) {
        currentData.verticalOsc = vertOsc;
        document.getElementById('verticalOscillation').innerHTML =
          vertOsc.toFixed(1) + '<span class="metric-unit">cm</span>';
      }

      // Foot strike
      const footStrike = detectFootStrike(kpMap);
      currentData.footStrike = footStrike;
      document.getElementById('footStrike').textContent = footStrike.replace('_', ' ');

      // --- Frontal plane metrics ---
      const pelvicDropFrontal = calculateFrontalPelvicDrop(kpMap);
      currentData.pelvicDropFrontal = pelvicDropFrontal;
      document.getElementById('pelvicDropFrontal').innerHTML =
        pelvicDropFrontal.toFixed(1) + '<span class="metric-unit">Â°</span>';

      const leftFPPA = calculateFPPA(kpMap[13], kpMap[11], kpMap[15]);
      const rightFPPA = calculateFPPA(kpMap[14], kpMap[12], kpMap[16]);
      currentData.kneeFpaaLeft = leftFPPA;
      currentData.kneeFpaaRight = rightFPPA;
      document.getElementById('kneeFpaaLeft').innerHTML =
        leftFPPA.toFixed(1) + '<span class="metric-unit">Â°</span>';
      document.getElementById('kneeFpaaRight').innerHTML =
        rightFPPA.toFixed(1) + '<span class="metric-unit">Â°</span>';

      const stepWidth = calculateStepWidth(kpMap);
      currentData.stepWidth = stepWidth;
      document.getElementById('stepWidth').innerHTML =
        stepWidth.toFixed(1) + '<span class="metric-unit">cm</span>';

      if (Math.abs(pelvicDropFrontal) > 10) {
        addIssue('warning', 'Excessive frontal pelvic drop');
        currentData.issues.push('Excessive frontal pelvic drop');
      }
      if (leftFPPA > 10 || rightFPPA > 10) {
        addIssue('warning', 'Increased frontal knee valgus (FPPA)');
        currentData.issues.push('Increased FPPA');
      }

      if (isRecording) {
        recordedData.push(currentData);

        chartData.timestamps.push(parseFloat(currentData.timestamp));
        chartData.kneeFlexionLeft.push(currentData.kneeFlexionLeft);
        chartData.kneeFlexionRight.push(currentData.kneeFlexionRight);
        chartData.cadence.push(currentData.cadence);
        chartData.hipDrop.push(currentData.hipDrop);
        chartData.verticalOsc.push(currentData.verticalOsc);
        chartData.contactTime.push(currentData.contactTime);
        chartData.pelvicDropFrontal.push(currentData.pelvicDropFrontal);
        chartData.kneeFpaaLeft.push(currentData.kneeFpaaLeft);
        chartData.kneeFpaaRight.push(currentData.kneeFpaaRight);

        if (recordedData.length % 10 === 0) updateCharts();
      }
    }

    function calculateGroundReactionForce(subject) {
      const g = 9.81;
      const mass = subject.mass;
      const bodyWeight = mass * g;

      let grfLeft = 0;
      let grfRight = 0;

      if (currentPhase === 'left_contact') {
        grfLeft = bodyWeight * 2.5;
        grfRight = bodyWeight * 0.2;
      } else if (currentPhase === 'right_contact') {
        grfRight = bodyWeight * 2.5;
        grfLeft = bodyWeight * 0.2;
      } else if (currentPhase === 'double_contact') {
        grfLeft = bodyWeight * 1.4;
        grfRight = bodyWeight * 1.4;
      } else if (currentPhase === 'flight') {
        grfLeft = 0;
        grfRight = 0;
      } else {
        grfLeft = bodyWeight * 0.5;
        grfRight = bodyWeight * 0.5;
      }

      return { left: grfLeft, right: grfRight };
    }

    function detectContactPhase(kpMap) {
      const hip = kpMap[11] || kpMap[12];
      const leftFoot = kpMap[15];
      const rightFoot = kpMap[16];

      const result = { phase: currentPhase, contactTime: 0, stanceFlightRatio: 0 };

      if (!hip || !leftFoot || !rightFoot) return result;

      const hipY = hip.y;
      const leftFootY = leftFoot.y;
      const rightFootY = rightFoot.y;

      const threshold = 0.2 * canvas.height;
      const leftContact = leftFootY > hipY + threshold;
      const rightContact = rightFootY > hipY + threshold;

      if (leftContact && !rightContact) {
        currentPhase = 'left_contact';
        document.getElementById('gaitPhase').textContent = 'Left Contact';
        updatePhaseIndicator(1);
      } else if (rightContact && !leftContact) {
        currentPhase = 'right_contact';
        document.getElementById('gaitPhase').textContent = 'Right Contact';
        updatePhaseIndicator(3);
      } else if (leftContact && rightContact) {
        currentPhase = 'double_contact';
        document.getElementById('gaitPhase').textContent = 'Double Contact';
        updatePhaseIndicator(2);
      } else {
        currentPhase = 'flight';
        document.getElementById('gaitPhase').textContent = 'Flight';
        updatePhaseIndicator(4);
      }

      const now = performance.now();
      if (!lastPhaseChangeTime) lastPhaseChangeTime = now;

      if (currentPhase !== lastPhase) {
        const duration = now - lastPhaseChangeTime;
        if (lastPhase === 'left_contact' || lastPhase === 'right_contact' || lastPhase === 'double_contact') {
          contactDurations.push(duration);
          if (contactDurations.length > 50) contactDurations.shift();
          result.contactTime = duration;
        }
        lastPhase = currentPhase;
        lastPhaseChangeTime = now;
      }

      if (contactDurations.length > 1) {
        const avgContact = contactDurations.reduce((a,b) => a + b, 0) / contactDurations.length;
        const cad = computeCadence(Date.now()) || 180;
        const estStepTime = 60000 / cad;
        const estFlight = Math.max(0, estStepTime - avgContact);
        result.stanceFlightRatio = estFlight / (avgContact || 1);
      }

      return result;
    }

    function computeCadence(now) {
      if (now - lastStepTime > 300 && now - lastStepTime < 2000) {
        stepHistory.push(now);
        if (stepHistory.length > 10) stepHistory.shift();
      }
      lastStepTime = now;

      if (stepHistory.length >= 2) {
        const avgStepTime = (stepHistory[stepHistory.length - 1] - stepHistory[0]) / (stepHistory.length - 1);
        return Math.round(60000 / avgStepTime);
      }
      return 0;
    }

    function calculateStrideLength(kpMap) {
      const leftFoot = kpMap[15];
      const rightFoot = kpMap[16];
      const heightCm = parseFloat(document.getElementById('subjectHeight').value) || 170;

      if (!leftFoot || !rightFoot || leftFoot.score < 0.5 || rightFoot.score < 0.5) return 0;

      const pixelToMeter = (heightCm / 100) / Math.max(canvas.width, canvas.height);
      const footSeparation = Math.abs(leftFoot.x - rightFoot.x) * pixelToMeter;
      if (footSeparation <= 0) return 0;

      return footSeparation * 100;
    }

    function calculateVerticalOscillation(kpMap) {
      const nose = kpMap[0];
      const midHipLeft = kpMap[11];
      const midHipRight = kpMap[12];

      if (!nose || !midHipLeft || !midHipRight) return 0;

      const comY = (nose.y + midHipLeft.y + midHipRight.y) / 3;
      comHeights.push(comY);
      if (comHeights.length > 60) comHeights.shift();

      if (comHeights.length < 10) return 0;

      const minCOM = Math.min(...comHeights);
      const maxCOM = Math.max(...comHeights);
      const verticalOscPixels = maxCOM - minCOM;

      const heightCm = parseFloat(document.getElementById('subjectHeight').value) || 170;
      const pixelToMeter = (heightCm / 100) / canvas.height;
      const oscillationCm = verticalOscPixels * pixelToMeter * 100;
      return oscillationCm;
    }

    function detectFootStrike(kpMap) {
      const leftHeel = kpMap[15];
      const rightHeel = kpMap[16];
      const leftKnee = kpMap[13];
      const rightKnee = kpMap[14];

      if (leftHeel && leftKnee && leftHeel.score > 0.5 && leftKnee.score > 0.5) {
        const heelToKneeX = leftHeel.x - leftKnee.x;
        if (heelToKneeX < -30) return 'heel_strike';
        if (Math.abs(heelToKneeX) < 30) return 'midfoot_strike';
        return 'forefoot_strike';
      }

      if (rightHeel && rightKnee && rightHeel.score > 0.5 && rightKnee.score > 0.5) {
        const heelToKneeX = rightHeel.x - rightKnee.x;
        if (heelToKneeX < -30) return 'heel_strike';
        if (Math.abs(heelToKneeX) < 30) return 'midfoot_strike';
        return 'forefoot_strike';
      }

      return 'unknown';
    }

    // Frontal-plane helpers
    function calculateFrontalPelvicDrop(kpMap) {
      const leftHip = kpMap[11];
      const rightHip = kpMap[12];
      if (!leftHip || !rightHip || leftHip.score < 0.5 || rightHip.score < 0.5) return 0;

      const dx = rightHip.x - leftHip.x;
      const dy = rightHip.y - leftHip.y;
      const angleDeg = Math.atan2(dy, dx || 1) * 180 / Math.PI;
      return angleDeg;
    }

    function calculateFPPA(knee, hip, ankle) {
      if (!knee || !hip || !ankle ||
          knee.score < 0.5 || hip.score < 0.5 || ankle.score < 0.5) return 0;

      const v1x = knee.x - hip.x;
      const v1y = knee.y - hip.y;
      const v2x = knee.x - ankle.x;
      const v2y = knee.y - ankle.y;

      const dot = v1x * v2x + v1y * v2y;
      const mag1 = Math.sqrt(v1x*v1x + v1y*v1y) || 1;
      const mag2 = Math.sqrt(v2x*v2x + v2y*v2y) || 1;
      let angle = Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2)))) * 180 / Math.PI;

      const midX = (hip.x + ankle.x) / 2;
      const medial = knee.x < midX;
      if (medial) angle = +angle;
      else angle = -angle;
      return angle;
    }

    function calculateStepWidth(kpMap) {
      const leftFoot = kpMap[15];
      const rightFoot = kpMap[16];
      const heightCm = parseFloat(document.getElementById('subjectHeight').value) || 170;

      if (!leftFoot || !rightFoot || leftFoot.score < 0.5 || rightFoot.score < 0.5) return 0;

      const pixelDistance = Math.abs(leftFoot.x - rightFoot.x);
      const pixelToMeter = (heightCm / 100) / Math.max(canvas.width, canvas.height);
      return pixelDistance * pixelToMeter * 100;
    }

    function updatePhaseIndicator(phase) {
      for (let i = 1; i <= 4; i++) {
        const dot = document.getElementById('phase' + i);
        if (dot) dot.classList.toggle('active', i === phase);
      }
    }

    function calculateAngle(a, b, c) {
      const radians = Math.atan2(c.y - b.y, c.x - b.x) -
                      Math.atan2(a.y - b.y, a.x - b.x);
      let angle = Math.abs(radians * 180 / Math.PI);
      if (angle > 180) angle = 360 - angle;
      return angle;
    }

    function addIssue(severity, message) {
      const key = severity + ':' + message;
      if (detectedIssues.has(key)) return;

      detectedIssues.add(key);
      const issuesList = document.getElementById('issuesList');

      if (detectedIssues.size === 1) issuesList.innerHTML = '';

      const issueDiv = document.createElement('div');
      issueDiv.className = 'issue-item ' + severity;
      issueDiv.textContent = message;
      issuesList.insertBefore(issueDiv, issuesList.firstChild);

      while (issuesList.children.length > 5) {
        issuesList.removeChild(issuesList.lastChild);
      }

      setTimeout(() => detectedIssues.delete(key), 5000);
    }

    function toggleRecording() {
      isRecording = !isRecording;
      recordBtn.classList.toggle('recording');

      if (isRecording) {
        sessionStartTime = performance.now();
        recordedData = [];
        chartData = {
          timestamps: [],
          kneeFlexionLeft: [],
          kneeFlexionRight: [],
          cadence: [],
          hipDrop: [],
          verticalOsc: [],
          contactTime: [],
          pelvicDropFrontal: [],
          kneeFpaaLeft: [],
          kneeFpaaRight: []
        };
        stepHistory = [];
        contactDurations = [];
        comHeights = [];
        lastPhase = currentPhase;
        lastPhaseChangeTime = performance.now();

        recordBtn.textContent = 'Stop Recording';
        exportBtn.disabled = true;

        statusDiv.className = 'status ready';
        statusDiv.innerHTML = 'ðŸ”´ Recording in Progress...';
      } else {
        recordBtn.textContent = 'Start Recording';
        exportBtn.disabled = recordedData.length === 0;

        statusDiv.className = 'status ready';
        statusDiv.innerHTML = 'âœ“ Recording Stopped - ' + recordedData.length + ' data points captured';
      }
    }

    function exportToCSV() {
      if (recordedData.length === 0) {
        alert('No data to export. Please record a session first.');
        return;
      }

      let csv = 'Gait Biodynamics Lab - Treadmill Running Report\n';
      csv += 'Subject: ' + subjectData.sex + ', Age: ' + subjectData.age +
             ' years, Mass: ' + subjectData.mass + ' kg, Height: ' + subjectData.height + ' cm\n';
      csv += 'Date: ' + new Date().toLocaleString() + '\n\n';

      csv += 'Timestamp (s),Knee Flexion Left (Â°),Knee Flexion Right (Â°),Hip Drop Sagittal (Â°),Cadence (steps/min),GRF Left (N),GRF Right (N),Stride Length (cm),Vertical Oscillation (cm),Contact Time (ms),Stance/Flight Ratio,Foot Strike,Overstride Risk,Gait Phase,Pelvic Drop Frontal (Â°),Knee FPPA Left (Â°),Knee FPPA Right (Â°),Step Width (cm),Issues\n';

      recordedData.forEach(row => {
        csv += [
          row.timestamp,
          row.kneeFlexionLeft,
          row.kneeFlexionRight,
          row.hipDrop,
          row.cadence,
          row.grfLeft.toFixed(1),
          row.grfRight.toFixed(1),
          (row.strideLength || 0).toFixed ? row.strideLength.toFixed(1) : (row.strideLength || 0),
          row.verticalOsc.toFixed ? row.verticalOsc.toFixed(2) : row.verticalOsc,
          row.contactTime.toFixed ? row.contactTime.toFixed(1) : row.contactTime,
          row.stanceFlightRatio.toFixed ? row.stanceFlightRatio.toFixed(2) : row.stanceFlightRatio,
          '"' + (row.footStrike || '') + '"',
          '"' + row.overstride + '"',
          '"' + row.gaitPhase + '"',
          row.pelvicDropFrontal.toFixed ? row.pelvicDropFrontal.toFixed(2) : row.pelvicDropFrontal,
          row.kneeFpaaLeft.toFixed ? row.kneeFpaaLeft.toFixed(2) : row.kneeFpaaLeft,
          row.kneeFpaaRight.toFixed ? row.kneeFpaaRight.toFixed(2) : row.kneeFpaaRight,
          row.stepWidth.toFixed ? row.stepWidth.toFixed(2) : row.stepWidth,
          '"' + row.issues.join('; ') + '"'
        ].join(',') + '\n';
      });

      csv += '\nSummary Statistics\n';
      csv += 'Metric,Average,Min,Max\n';

      function addSummaryRow(label, arrAccessor) {
        const arr = recordedData.map(arrAccessor).filter(v => typeof v === 'number' && !isNaN(v));
        if (!arr.length) return;
        const avg = arr.reduce((s, v) => s + v, 0) / arr.length;
        const min = Math.min(...arr);
        const max = Math.max(...arr);
        csv += label + ',' + avg.toFixed(2) + ',' + min.toFixed(2) + ',' + max.toFixed(2) + '\n';
      }

      addSummaryRow('Knee Flexion Left (Â°)', d => d.kneeFlexionLeft);
      addSummaryRow('Knee Flexion Right (Â°)', d => d.kneeFlexionRight);
      addSummaryRow('Hip Drop Sagittal (Â°)', d => d.hipDrop);
      addSummaryRow('Cadence (steps/min)', d => d.cadence);
      addSummaryRow('Stride Length (cm)', d => d.strideLength || 0);
      addSummaryRow('Vertical Oscillation (cm)', d => d.verticalOsc || 0);
      addSummaryRow('Contact Time (ms)', d => d.contactTime || 0);
      addSummaryRow('Stance/Flight Ratio', d => d.stanceFlightRatio || 0);
      addSummaryRow('Pelvic Drop Frontal (Â°)', d => d.pelvicDropFrontal || 0);
      addSummaryRow('Knee FPPA Left (Â°)', d => d.kneeFpaaLeft || 0);
      addSummaryRow('Knee FPPA Right (Â°)', d => d.kneeFpaaRight || 0);
      addSummaryRow('Step Width (cm)', d => d.stepWidth || 0);

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const timeStr = new Date().toISOString().replace(/[:.]/g, '-');
      a.download = 'gait_running_report_' + timeStr + '.csv';
      a.click();
      URL.revokeObjectURL(url);

      statusDiv.className = 'status ready';
      statusDiv.innerHTML = 'âœ“ CSV file exported successfully!';
    }

    // =========================
    // Event listeners
    // =========================
    window.addEventListener('load', init);
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    recordBtn.addEventListener('click', toggleRecording);
    exportBtn.addEventListener('click', exportToCSV);
  </script>
</body>
</html>
