<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gait Biodynamics Lab - Pose Estimation for Running Biomechanics</title>
  <meta name="description" content="AI-powered gait analysis tool for runners and physical therapists. Step-based running gait metrics using pose estimation.">

  <!-- TFJS + Pose Detection -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.0"></script>

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>

  <!-- XLSX export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 { text-align: center; color: #667eea; margin-bottom: 10px; font-size: 2.5em; }
    .subtitle { text-align: center; color: #666; margin-bottom: 30px; }

    .main-content { display: grid; grid-template-columns: 2fr 1fr; gap: 30px; margin-bottom: 20px; }
    @media (max-width: 968px) {
      .main-content { grid-template-columns: 1fr; }
      h1 { font-size: 1.8em; }
    }

    .video-section { position: relative; }
    #videoContainer {
      position: relative;
      width: 100%;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    #webcam { width: 100%; display: block; }
    #canvas {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
    }
    .fps-indicator {
      position: absolute;
      top: 10px; right: 10px;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      padding: 8px 15px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 14px;
      z-index: 10;
    }
    .controls { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; }
    button {
      flex: 1;
      min-width: 160px;
      padding: 15px 25px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #startBtn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
    #stopBtn { background: #e74c3c; color: white; }
    #recordBtn { background: #27ae60; color: white; }
    #recordBtn.recording { background: #e74c3c; animation: pulse 1.5s infinite; }
    #exportBtn { background: #3498db; color: white; }
    #snapshotBtn { background: #8e44ad; color: white; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

    .analysis-panel { background: #f8f9fa; border-radius: 15px; padding: 20px; height: fit-content; }
    .metrics { display: grid; gap: 15px; }
    .metric-card {
      background: white;
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .metric-label { font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; }
    .metric-value { font-size: 22px; font-weight: bold; color: #333; }
    .metric-unit { font-size: 14px; color: #999; margin-left: 5px; }

    .status { padding: 10px; border-radius: 8px; margin-bottom: 20px; text-align: center; font-weight: 600; }
    .status.loading { background: #fff3cd; color: #856404; }
    .status.ready { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }

    .gait-phase {
      background: white;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .phase-indicator { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; }
    .phase-dot {
      width: 40px; height: 40px;
      border-radius: 50%;
      background: #e0e0e0;
      display: flex; align-items: center; justify-content: center;
      font-size: 10px; font-weight: bold;
      color: #999;
      transition: all 0.3s;
    }
    .phase-dot.active { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; transform: scale(1.2); }

    .issues-list { background: white; padding: 15px; border-radius: 10px; max-height: 200px; overflow-y: auto; }
    .issue-item { padding: 10px; margin-bottom: 8px; border-radius: 5px; font-size: 14px; }
    .issue-item.warning { background: #fff3cd; border-left: 3px solid #ffc107; }
    .issue-item.critical { background: #f8d7da; border-left: 3px solid #dc3545; }

    .loading-spinner {
      display: inline-block;
      width: 20px; height: 20px;
      border: 3px solid rgba(102, 126, 234, 0.3);
      border-radius: 50%;
      border-top-color: #667eea;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .charts-section { margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 15px; }
    .charts-section h3 { color: #667eea; margin-bottom: 15px; }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .chart-container canvas { max-height: 300px; }

    .info-section { margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 15px; }
    .info-section h3 { color: #667eea; margin-bottom: 15px; }
    .info-section ul { margin-left: 20px; line-height: 1.8; }

    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      color: white;
      background: #667eea;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üèÉ Gait Biodynamics Lab</h1>
    <p class="subtitle">Concurrent Left/Right Step Tracking ‚Ä¢ Sagittal & Frontal Modes ‚Ä¢ XLSX + PNG Export</p>

    <div id="status" class="status loading">
      <span class="loading-spinner"></span> Initializing AI Model...
    </div>

    <div class="info-section">
      <h3>üë§ Subject & Camera Setup</h3>
      <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); gap: 15px; margin-top: 15px;">
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">View Mode:</label>
          <select id="viewMode" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
            <option value="sagittal" selected>Sagittal (Side View)</option>
            <option value="frontal">Frontal (Front/Back View)</option>
          </select>
          <div style="margin-top:6px; font-size:12px; color:#666;">
            Sagittal: overstride meaningful. Frontal: valgus/step width meaningful.
          </div>
        </div>

        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Sex:</label>
          <select id="subjectSex" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
            <option value="male">Male</option>
            <option value="female">Female</option>
          </select>
        </div>
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Age (years):</label>
          <input type="number" id="subjectAge" min="1" max="120" value="30" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
        </div>
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Mass (kg):</label>
          <input type="number" id="subjectMass" min="20" max="300" value="70" step="0.1" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
        </div>
        <div>
          <label style="display:block; margin-bottom:5px; font-weight:600; color:#666;">Height (cm):</label>
          <input type="number" id="subjectHeight" min="100" max="250" value="170" step="0.1" style="width:100%; padding:10px; border:2px solid #667eea; border-radius:8px; font-size:14px;">
        </div>
      </div>

      <div style="margin-top: 12px; font-size: 12px; color:#666;">
        Scaling: cm/pixel uses (nose ‚Üí lowest ankle) vs your entered height. Keep full body visible for best stride/width estimates.
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <div id="videoContainer">
          <div class="fps-indicator" id="fpsDisplay">FPS: 0</div>
          <video id="webcam" autoplay playsinline muted></video>
          <canvas id="canvas"></canvas>
        </div>
        <div class="controls">
          <button id="startBtn" disabled>Start Camera</button>
          <button id="stopBtn" disabled>Stop Camera</button>
          <button id="recordBtn" disabled>Start Recording</button>
          <button id="exportBtn" disabled>Export XLSX</button>
          <button id="snapshotBtn" disabled>Snapshot PNG</button>
        </div>
      </div>

      <div class="analysis-panel">
        <h3 style="margin-bottom: 10px; color: #667eea;">
          Real-Time (Per-Step)
          <span class="pill" id="modePill">SAGITTAL</span>
        </h3>

        <div class="gait-phase">
          <div class="metric-label">Current Phase</div>
          <div class="metric-value" id="gaitPhase">Standing</div>
          <div class="phase-indicator">
            <div class="phase-dot" id="phase1">IC</div>
            <div class="phase-dot" id="phase2">MS</div>
            <div class="phase-dot" id="phase3">TO</div>
            <div class="phase-dot" id="phase4">SW</div>
          </div>
          <div style="font-size: 10px; color: #999; margin-top: 10px; text-align: center;">
            IC: Initial Contact | MS: Mid Stance | TO: Toe Off | SW: Swing
          </div>
        </div>

        <div class="metrics">
          <div class="metric-card">
            <div class="metric-label">Cadence (last ~8 IC)</div>
            <div class="metric-value" id="cadence">0<span class="metric-unit">steps/min</span></div>
          </div>

          <div class="metric-card">
            <div class="metric-label">Stance Time Avg (last ~6 steps)</div>
            <div class="metric-value" id="stanceTime">0<span class="metric-unit">s</span></div>
          </div>

          <div class="metric-card">
            <div class="metric-label">Swing Time Avg (last ~6 steps)</div>
            <div class="metric-value" id="swingTime">0<span class="metric-unit">s</span></div>
          </div>

          <div class="metric-card">
            <div class="metric-label">Stride Length Avg (last ~6)</div>
            <div class="metric-value" id="strideLength">0<span class="metric-unit">cm</span></div>
          </div>

          <div class="metric-card">
            <div class="metric-label">Knee Min in Stance (L) - last</div>
            <div class="metric-value" id="kneeMinL">0<span class="metric-unit">¬∞</span></div>
          </div>

          <div class="metric-card">
            <div class="metric-label">Knee Min in Stance (R) - last</div>
            <div class="metric-value" id="kneeMinR">0<span class="metric-unit">¬∞</span></div>
          </div>

          <div class="metric-card">
            <div class="metric-label">Hip Drop Max (last step)</div>
            <div class="metric-value" id="hipDrop">0<span class="metric-unit">¬∞</span></div>
          </div>

          <!-- Mode-dependent metric -->
          <div class="metric-card">
            <div class="metric-label" id="modeMetricLabel">Overstride Risk (last IC)</div>
            <div class="metric-value" id="modeMetricValue">Low</div>
          </div>

          <div class="metric-card">
            <div class="metric-label">Step Width (frontal)</div>
            <div class="metric-value" id="stepWidth">0<span class="metric-unit">cm</span></div>
          </div>
        </div>

        <div style="margin-top: 20px;">
          <div class="metric-label">Detected Issues (per-step)</div>
          <div class="issues-list" id="issuesList">
            <div style="text-align: center; color: #999; padding: 20px;">No issues detected yet</div>
          </div>
        </div>
      </div>
    </div>

    <div class="charts-section">
      <h3>üìä Per-Step Charts</h3>
      <div class="chart-container"><canvas id="strideChart"></canvas></div>
      <div class="chart-container"><canvas id="stanceChart"></canvas></div>
      <div class="chart-container"><canvas id="kneeMinChart"></canvas></div>
    </div>

    <div class="info-section">
      <h3>üìã Notes</h3>
      <ul>
        <li>Step detection is based on ankle contact vs an adaptive ground baseline (camera-dependent).</li>
        <li>For frontal view, ‚Äúvalgus‚Äù here is a proxy (2D medial knee drift), not a clinical 3D measure.</li>
        <li>iPhone export uses Share sheet (Save to Files). Fully automatic saving isn‚Äôt permitted by iOS.</li>
      </ul>
    </div>
  </div>

  <script>
    // ============================================================
    // Globals
    // ============================================================
    let detector;
    let webcam, canvas, ctx;
    let animationId;
    let isRunning = false;
    let isRecording = false;

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

    let subjectData = { sex: 'male', age: 30, mass: 70, height: 170 };

    // FPS
    let fps = 0, frameCount = 0, fpsUpdateTime = 0;

    // UI
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordBtn = document.getElementById('recordBtn');
    const exportBtn = document.getElementById('exportBtn');
    const snapshotBtn = document.getElementById('snapshotBtn');
    const statusDiv = document.getElementById('status');

    const viewModeEl = document.getElementById('viewMode');
    const modePill = document.getElementById('modePill');
    const modeMetricLabel = document.getElementById('modeMetricLabel');
    const modeMetricValue = document.getElementById('modeMetricValue');

    // Issues (de-dupe)
    let detectedIssues = new Set();

    // ============================================================
    // Charts
    // ============================================================
    let strideChart, stanceChart, kneeMinChart;

    function initCharts() {
      const commonOptions = {
        responsive: true,
        maintainAspectRatio: true,
        animation: false,
        scales: {
          x: { display: true, title: { display: true, text: 'Step #' } },
          y: { display: true, beginAtZero: false }
        },
        plugins: { legend: { display: true } }
      };

      strideChart = new Chart(document.getElementById('strideChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Stride Length (cm)',
            data: [],
            tension: 0.35
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'cm' }, suggestedMin: 50, suggestedMax: 200 }
          }
        }
      });

      stanceChart = new Chart(document.getElementById('stanceChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Stance Time (s)',
            data: [],
            tension: 0.35
          },{
            label: 'Swing Time (s)',
            data: [],
            tension: 0.35
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'seconds' }, suggestedMin: 0.1, suggestedMax: 0.8 }
          }
        }
      });

      kneeMinChart = new Chart(document.getElementById('kneeMinChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Knee Min L (¬∞)',
            data: [],
            tension: 0.35
          },{
            label: 'Knee Min R (¬∞)',
            data: [],
            tension: 0.35
          }]
        },
        options: {
          ...commonOptions,
          scales: {
            ...commonOptions.scales,
            y: { ...commonOptions.scales.y, title: { display: true, text: 'degrees' }, suggestedMin: 80, suggestedMax: 180 }
          }
        }
      });
    }

    function updateChartsFromSteps() {
      const steps = gait.steps;
      const maxPoints = 90;
      const start = Math.max(0, steps.length - maxPoints);
      const slice = steps.slice(start);
      const labels = slice.map((s) => String(s.idx));

      strideChart.data.labels = labels;
      strideChart.data.datasets[0].data = slice.map(s => (typeof s.strideCm === 'number') ? s.strideCm : null);
      strideChart.update('none');

      stanceChart.data.labels = labels;
      stanceChart.data.datasets[0].data = slice.map(s => (typeof s.stanceTimeS === 'number') ? s.stanceTimeS : null);
      stanceChart.data.datasets[1].data = slice.map(s => (typeof s.swingTimeS === 'number') ? s.swingTimeS : null);
      stanceChart.update('none');

      kneeMinChart.data.labels = labels;
      kneeMinChart.data.datasets[0].data = slice.map(s => (s.side === 'L' && typeof s.kneeMinDeg === 'number') ? s.kneeMinDeg : null);
      kneeMinChart.data.datasets[1].data = slice.map(s => (s.side === 'R' && typeof s.kneeMinDeg === 'number') ? s.kneeMinDeg : null);
      kneeMinChart.update('none');
    }

    // ============================================================
    // Gait State (CONCURRENT LEFT/RIGHT)
    // ============================================================
    const gait = {
      feet: {
        L: makeFootState('L'),
        R: makeFootState('R'),
      },
      steps: [],                 // finalized steps (both sides interleaved)
      icTimes: [],               // for cadence (ms)
      recentWindow: 6
    };

    function makeFootState(side) {
      return {
        side,
        groundY: null,
        contact: false,
        prev: { t: 0, x: 0, y: 0, ok: false },
        active: null,            // active stance step object
        lastTO: null,            // ms
        lastIC: null,            // ms
        lastIC_hipX: null        // px at IC (hip-mid X)
      };
    }

    function resetGaitAll() {
      gait.feet.L = makeFootState('L');
      gait.feet.R = makeFootState('R');
      gait.steps = [];
      gait.icTimes = [];
      detectedIssues = new Set();

      document.getElementById('issuesList').innerHTML =
        '<div style="text-align:center; color:#999; padding:20px;">No issues detected yet</div>';

      // reset UI
      document.getElementById('cadence').innerHTML = `0<span class="metric-unit">steps/min</span>`;
      document.getElementById('stanceTime').innerHTML = `0<span class="metric-unit">s</span>`;
      document.getElementById('swingTime').innerHTML = `0<span class="metric-unit">s</span>`;
      document.getElementById('strideLength').innerHTML = `0<span class="metric-unit">cm</span>`;
      document.getElementById('kneeMinL').innerHTML = `0<span class="metric-unit">¬∞</span>`;
      document.getElementById('kneeMinR').innerHTML = `0<span class="metric-unit">¬∞</span>`;
      document.getElementById('hipDrop').innerHTML = `0<span class="metric-unit">¬∞</span>`;
      document.getElementById('stepWidth').innerHTML = `0<span class="metric-unit">cm</span>`;
      modeMetricValue.textContent = (viewMode() === 'sagittal') ? 'Low' : '0¬∞';

      // charts
      if (strideChart) { strideChart.data.labels = []; strideChart.data.datasets[0].data = []; strideChart.update('none'); }
      if (stanceChart) { stanceChart.data.labels = []; stanceChart.data.datasets[0].data = []; stanceChart.data.datasets[0].data = []; stanceChart.update('none'); }
      if (kneeMinChart) { kneeMinChart.data.labels = []; kneeMinChart.data.datasets[0].data = []; kneeMinChart.data.datasets[1].data = []; kneeMinChart.update('none'); }
    }

    // ============================================================
    // TFJS backend init (fix WebGPU init error)
    // ============================================================
    async function initTFBackend() {
      await tf.ready();
      const preferred = (isIOS || isSafari) ? ['webgl', 'cpu'] : ['webgpu', 'webgl', 'cpu'];

      let ok = false;
      for (const b of preferred) {
        try {
          await tf.setBackend(b);
          await tf.ready();
          ok = true;
          break;
        } catch (_) {}
      }
      if (!ok) throw new Error('No TFJS backend could be initialized.');
      return tf.getBackend();
    }

    async function init() {
      try {
        statusDiv.className = 'status loading';
        statusDiv.innerHTML = '<span class="loading-spinner"></span> Loading TensorFlow backend...';
        const backend = await initTFBackend();

        statusDiv.className = 'status loading';
        statusDiv.innerHTML = `<span class="loading-spinner"></span> Loading MoveNet (backend: ${backend})...`;

        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          {
            modelType: (isIOS || isSafari)
              ? poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
              : poseDetection.movenet.modelType.SINGLEPOSE_THUNDER,
            enableTracking: true,
            trackerType: poseDetection.TrackerType.BoundingBox
          }
        );

        initCharts();
        syncModeUI();

        statusDiv.className = 'status ready';
        statusDiv.innerHTML = `‚úì AI Model Ready (backend: ${backend}) - Click "Start Camera"`;
        startBtn.disabled = false;
      } catch (e) {
        statusDiv.className = 'status error';
        statusDiv.innerHTML = '‚úó Error loading model: ' + (e?.message || e);
        console.error(e);
      }
    }

    function viewMode() {
      return viewModeEl.value; // 'sagittal' | 'frontal'
    }

    function syncModeUI() {
      const m = viewMode();
      modePill.textContent = m.toUpperCase();
      if (m === 'sagittal') {
        modePill.style.background = '#667eea';
        modeMetricLabel.textContent = 'Overstride Risk (last IC)';
        modeMetricValue.textContent = 'Low';
      } else {
        modePill.style.background = '#e67e22';
        modeMetricLabel.textContent = 'Knee Medial Drift (proxy) - last';
        modeMetricValue.textContent = '0¬∞';
      }
    }

    // ============================================================
    // Camera (iOS-safe constraints)
    // ============================================================
    async function startCamera() {
      try {
        webcam = document.getElementById('webcam');
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');

        webcam.muted = true;
        webcam.playsInline = true;
        webcam.setAttribute('playsinline', '');
        webcam.setAttribute('muted', '');
        webcam.setAttribute('autoplay', '');

        const tryConstraints = [
          { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 120 } } },
          { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 60 } } },
          { video: { facingMode: 'environment' } }
        ];

        let stream = null, lastErr = null;
        for (const c of tryConstraints) {
          try { stream = await navigator.mediaDevices.getUserMedia(c); break; }
          catch (e) { lastErr = e; }
        }
        if (!stream) throw lastErr || new Error('Unable to access camera');

        webcam.srcObject = stream;
        await new Promise(res => webcam.onloadeddata = () => res());
        await webcam.play();

        canvas.width = webcam.videoWidth || 640;
        canvas.height = webcam.videoHeight || 480;

        resetGaitAll();

        isRunning = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        recordBtn.disabled = false;
        snapshotBtn.disabled = false;
        exportBtn.disabled = true;

        statusDiv.className = 'status ready';
        statusDiv.innerHTML = 'üé• Camera Active - Ready';

        fpsUpdateTime = performance.now();
        frameCount = 0;
        detectPose();

        // Negotiated camera fps
        const track = stream.getVideoTracks()[0];
        const settings = track.getSettings ? track.getSettings() : {};
        const gotFps = settings.frameRate ? Math.round(settings.frameRate) : '?';
        document.getElementById('fpsDisplay').textContent = `FPS: 0 (Cam: ${gotFps})`;
      } catch (e) {
        statusDiv.className = 'status error';
        statusDiv.innerHTML = '‚úó Camera Error: ' + (e?.message || e);
        console.error(e);
      }
    }

    function stopCamera() {
      if (webcam && webcam.srcObject) {
        webcam.srcObject.getTracks().forEach(t => t.stop());
        webcam.srcObject = null;
      }
      if (animationId) cancelAnimationFrame(animationId);

      isRunning = false;
      if (isRecording) toggleRecording(); // stop recording cleanly

      startBtn.disabled = false;
      stopBtn.disabled = true;
      recordBtn.disabled = true;
      exportBtn.disabled = true;
      snapshotBtn.disabled = true;

      if (ctx && canvas) ctx.clearRect(0, 0, canvas.width, canvas.height);

      statusDiv.className = 'status';
      statusDiv.innerHTML = 'Camera Stopped - Click "Start Camera" to resume';
      document.getElementById('fpsDisplay').textContent = 'FPS: 0';
    }

    // ============================================================
    // Pose loop
    // ============================================================
    async function detectPose() {
      if (!isRunning) return;

      const now = performance.now();

      // FPS calc
      frameCount++;
      if (now - fpsUpdateTime >= 1000) {
        fps = Math.round(frameCount * 1000 / (now - fpsUpdateTime));
        document.getElementById('fpsDisplay').textContent = `FPS: ${fps}`;
        frameCount = 0;
        fpsUpdateTime = now;
      }

      try {
        const poses = await detector.estimatePoses(webcam);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (poses.length > 0 && poses[0]?.keypoints?.length) {
          const kps = poses[0].keypoints;
          drawSkeleton(kps);
          analyzePerFrame(kps, now);
        }
      } catch (e) {
        console.error('Pose error:', e);
      }

      animationId = requestAnimationFrame(detectPose);
    }

    // ============================================================
    // Drawing
    // ============================================================
    function drawSkeleton(keypoints) {
      const conns = [
        { a: 5, b: 7, c: '#3498db' }, { a: 7, b: 9, c: '#3498db' },
        { a: 5, b: 11, c: '#3498db' }, { a: 11, b: 13, c: '#3498db' }, { a: 13, b: 15, c: '#3498db' },
        { a: 6, b: 8, c: '#2ecc71' }, { a: 8, b: 10, c: '#2ecc71' },
        { a: 6, b: 12, c: '#2ecc71' }, { a: 12, b: 14, c: '#2ecc71' }, { a: 14, b: 16, c: '#2ecc71' },
        { a: 5, b: 6, c: '#9b59b6' }, { a: 11, b: 12, c: '#9b59b6' }
      ];

      ctx.lineWidth = 5;
      for (const conn of conns) {
        const p1 = keypoints[conn.a], p2 = keypoints[conn.b];
        if (p1?.score > 0.3 && p2?.score > 0.3) {
          ctx.strokeStyle = conn.c;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }

      for (let i = 0; i < keypoints.length; i++) {
        const kp = keypoints[i];
        if (kp?.score > 0.3) {
          ctx.beginPath();
          ctx.arc(kp.x, kp.y, 8, 0, 2*Math.PI);
          if ([5,7,9,11,13,15].includes(i)) ctx.fillStyle = '#3498db';
          else if ([6,8,10,12,14,16].includes(i)) ctx.fillStyle = '#2ecc71';
          else ctx.fillStyle = '#9b59b6';
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }

    // ============================================================
    // Per-frame analysis (concurrent L/R)
    // ============================================================
    function analyzePerFrame(kps, tNow) {
      // Subject
      subjectData.sex = document.getElementById('subjectSex').value;
      subjectData.age = parseFloat(document.getElementById('subjectAge').value || '0');
      subjectData.mass = parseFloat(document.getElementById('subjectMass').value || '0');
      subjectData.height = parseFloat(document.getElementById('subjectHeight').value || '0');

      const m = viewMode();
      const get = (i) => (kps[i] && kps[i].score > 0.3) ? kps[i] : null;

      const nose = get(0);
      const hipL = get(11), hipR = get(12);
      const kneeL = get(13), kneeR = get(14);
      const ankleL = get(15), ankleR = get(16);

      if (!ankleL && !ankleR) return;

      const pxToCm = estimatePxToCm(nose, ankleL, ankleR, subjectData.height);

      // Step width (frontal only meaningful, but safe to show always)
      const stepWidthCm = (ankleL && ankleR && pxToCm) ? Math.abs(ankleL.x - ankleR.x) * pxToCm : 0;
      document.getElementById('stepWidth').innerHTML = `${stepWidthCm.toFixed(0)}<span class="metric-unit">cm</span>`;

      // Hip drop (always)
      const hipDropDeg = computeHipDropDeg(hipL, hipR);

      // Knee angles
      const kneeDegL = (hipL && kneeL && ankleL) ? calculateAngle(hipL, kneeL, ankleL) : null;
      const kneeDegR = (hipR && kneeR && ankleR) ? calculateAngle(hipR, kneeR, ankleR) : null;

      // Frontal knee medial drift proxy (degrees-ish)
      // We treat "medial drift" as how much the knee is shifted toward body midline relative to hip & ankle
      const kneeMedialDrift = (m === 'frontal') ? computeKneeMedialDriftProxyDeg(hipL, kneeL, ankleL, hipR, kneeR, ankleR) : null;
      if (m === 'frontal') {
        modeMetricValue.textContent = (kneeMedialDrift != null) ? `${kneeMedialDrift.toFixed(1)}¬∞` : '0¬∞';
      }

      // Update each foot contact + events independently
      handleFoot('L', tNow, ankleL, hipL, hipR, kneeDegL, hipDropDeg, pxToCm);
      handleFoot('R', tNow, ankleR, hipL, hipR, kneeDegR, hipDropDeg, pxToCm);

      // UI phase label (simple view)
      updatePhaseUI(gait.feet.L.contact, gait.feet.R.contact);

      // Cadence from last IC times
      updateCadenceUI();

      // Averages and last-step UI
      updateRollingUI();

      // Enable export if we have steps
      exportBtn.disabled = gait.steps.length === 0;
    }

    function handleFoot(side, tNow, ankle, hipL, hipR, kneeDeg, hipDropDeg, pxToCm) {
      const f = gait.feet[side];
      if (!ankle) return;

      // ground baseline (slowly follows maximum y)
      const alpha = 0.05;
      if (f.groundY == null) f.groundY = ankle.y;
      f.groundY = (1 - alpha) * f.groundY + alpha * Math.max(f.groundY, ankle.y);

      // contact with hysteresis
      const thrOn = 18;   // enter contact
      const thrOff = 26;  // exit contact
      const dist = f.groundY - ankle.y; // smaller means closer to ground baseline

      let contactNow = f.contact;
      if (!f.contact && dist < thrOn) contactNow = true;
      if (f.contact && dist > thrOff) contactNow = false;

      // vertical velocity
      const dt = Math.max(1e-3, (tNow - f.prev.t) / 1000);
      const vY = (f.prev.ok) ? (ankle.y - f.prev.y) / dt : 0;

      const ic = (!f.contact && contactNow && vY > -400);
      const to = (f.contact && !contactNow);

      // IC event
      if (ic) {
        onInitialContact(side, tNow, ankle, hipL, hipR, pxToCm);

        // update other metrics at IC (mode-dependent)
        if (viewMode() === 'sagittal') {
          const hipMidX = midX(hipL, hipR);
          const over = computeOverstrideRisk(hipMidX, ankle, canvas.height || 1);
          modeMetricValue.textContent = over.level;
          if (over.level === 'High') addIssue('critical', `${side}: Overstriding at IC`);
          else if (over.level === 'Moderate') addIssue('warning', `${side}: Moderate overstride at IC`);
        }
      }

      // If in stance, accumulate
      if (f.active && f.active.inStance) {
        if (kneeDeg != null) f.active.kneeMinDeg = Math.min(f.active.kneeMinDeg, kneeDeg);
        if (hipDropDeg != null) f.active.hipDropMaxDeg = Math.max(f.active.hipDropMaxDeg, hipDropDeg);
      }

      // TO event
      if (to) {
        onToeOff(side, tNow);
      }

      // persist
      f.contact = contactNow;
      f.prev = { t: tNow, x: ankle.x, y: ankle.y, ok: true };
    }

    function onInitialContact(side, tIC, ankle, hipL, hipR, pxToCm) {
      if (!isRecording) return;

      const f = gait.feet[side];
      const hipMidX = midX(hipL, hipR);

      // 1) Swing time for the *previous* step of this same foot (TO -> this IC)
      const lastStepSameFoot = findLastStepOfSide(side);
      if (lastStepSameFoot && typeof lastStepSameFoot.tTO_ms === 'number' && typeof lastStepSameFoot.swingTimeS !== 'number') {
        lastStepSameFoot.swingTimeS = (tIC - lastStepSameFoot.tTO_ms) / 1000;
      }

      // 2) Stride length for the *previous* same-foot IC (IC -> this IC), using hipMidX displacement
      if (pxToCm && f.lastIC != null && f.lastIC_hipX != null && hipMidX != null) {
        const strideCm = Math.abs(hipMidX - f.lastIC_hipX) * pxToCm;
        if (lastStepSameFoot && typeof lastStepSameFoot.strideCm !== 'number') {
          lastStepSameFoot.strideCm = strideCm;
        }
      }

      // 3) Create NEW active stance step for this foot
      f.active = {
        side,
        idx: gait.steps.length + 1, // provisional; we assign on finalize
        tIC_ms: tIC,
        tTO_ms: null,
        inStance: true,
        stanceTimeS: null,
        swingTimeS: null,
        strideCm: null,
        kneeMinDeg: 999,
        hipDropMaxDeg: 0,
        overstrideLevel: null,
        overstrideRatio: null,
        notes: ''
      };

      // 4) Update cadence IC times
      gait.icTimes.push(tIC);
      if (gait.icTimes.length > 12) gait.icTimes.shift();

      // 5) Update stored IC references for stride calc next time
      f.lastIC = tIC;
      f.lastIC_hipX = (hipMidX != null) ? hipMidX : null;

      setPhaseIndicator(1);
    }

    function onToeOff(side, tTO) {
      if (!isRecording) return;

      const f = gait.feet[side];
      if (!f.active || !f.active.inStance) return;

      f.active.tTO_ms = tTO;
      f.active.inStance = false;
      f.active.stanceTimeS = (tTO - f.active.tIC_ms) / 1000;

      // basic per-step issues
      if (f.active.kneeMinDeg !== 999 && f.active.kneeMinDeg > 165) {
        addIssue('warning', `${side}: Insufficient knee flexion during stance`);
        f.active.notes += 'Insufficient knee flexion; ';
      }
      if (f.active.hipDropMaxDeg > 8) {
        addIssue('critical', `${side}: Excessive hip drop`);
        f.active.notes += 'Excessive hip drop; ';
      }

      // finalize this step now (stride/swing may be filled later at next IC)
      finalizeStep(f.active);

      // remember TO
      f.lastTO = tTO;

      // clear active
      f.active = null;

      setPhaseIndicator(3);
    }

    function finalizeStep(step) {
      step.idx = gait.steps.length + 1;

      if (step.kneeMinDeg === 999) step.kneeMinDeg = null;

      gait.steps.push({
        idx: step.idx,
        side: step.side,
        tIC_ms: step.tIC_ms,
        tTO_ms: step.tTO_ms,
        stanceTimeS: step.stanceTimeS,
        swingTimeS: step.swingTimeS,
        strideCm: step.strideCm,
        kneeMinDeg: step.kneeMinDeg,
        hipDropMaxDeg: step.hipDropMaxDeg,
        notes: (step.notes || '').trim()
      });

      if (gait.steps.length % 2 === 0) updateChartsFromSteps();
    }

    function findLastStepOfSide(side) {
      for (let i = gait.steps.length - 1; i >= 0; i--) {
        if (gait.steps[i].side === side) return gait.steps[i];
      }
      return null;
    }

    // ============================================================
    // UI helpers
    // ============================================================
    function updatePhaseUI(L_contact, R_contact) {
      let label = 'Standing';
      let dot = 1;

      if (L_contact && R_contact) { label = 'Double Support'; dot = 2; }
      else if (L_contact && !R_contact) { label = 'Right Swing'; dot = 4; }
      else if (!L_contact && R_contact) { label = 'Left Swing'; dot = 4; }
      else if (!L_contact && !R_contact) { label = 'Flight / Both Swing'; dot = 4; }

      document.getElementById('gaitPhase').textContent = label;
      setPhaseIndicator(dot);
    }

    function setPhaseIndicator(phase) {
      for (let i = 1; i <= 4; i++) {
        const dot = document.getElementById('phase' + i);
        if (dot) dot.classList.toggle('active', i === phase);
      }
    }

    function updateCadenceUI() {
      const t = gait.icTimes;
      if (t.length < 4) return;

      const lastN = 8;
      const slice = t.slice(-lastN);

      const deltas = [];
      for (let i = 1; i < slice.length; i++) deltas.push((slice[i] - slice[i-1]) / 1000);
      const avg = deltas.reduce((a,b)=>a+b,0) / deltas.length;
      const cadence = avg > 0 ? Math.round(60 / avg) : 0;

      document.getElementById('cadence').innerHTML = `${cadence}<span class="metric-unit">steps/min</span>`;
      if (cadence > 0 && cadence < 160) addIssue('warning', 'Low cadence - consider increasing step rate');
    }

    function updateRollingUI() {
      const steps = gait.steps;
      if (!steps.length) return;

      const n = gait.recentWindow;
      const slice = steps.slice(-n);

      const nums = (k) => slice.map(s => s[k]).filter(v => typeof v === 'number' && isFinite(v));
      const mean = (arr) => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;

      const stanceAvg = mean(nums('stanceTimeS'));
      const swingAvg = mean(nums('swingTimeS'));
      const strideAvg = mean(nums('strideCm'));

      document.getElementById('stanceTime').innerHTML = `${stanceAvg.toFixed(2)}<span class="metric-unit">s</span>`;
      document.getElementById('swingTime').innerHTML = `${swingAvg.toFixed(2)}<span class="metric-unit">s</span>`;
      document.getElementById('strideLength').innerHTML = `${strideAvg.toFixed(0)}<span class="metric-unit">cm</span>`;

      const last = steps[steps.length - 1];
      document.getElementById('hipDrop').innerHTML = `${(last.hipDropMaxDeg ?? 0).toFixed(1)}<span class="metric-unit">¬∞</span>`;

      if (last.side === 'L') document.getElementById('kneeMinL').innerHTML = `${(last.kneeMinDeg ?? 0).toFixed(0)}<span class="metric-unit">¬∞</span>`;
      if (last.side === 'R') document.getElementById('kneeMinR').innerHTML = `${(last.kneeMinDeg ?? 0).toFixed(0)}<span class="metric-unit">¬∞</span>`;
    }

    // ============================================================
    // Geometry / metrics
    // ============================================================
    function estimatePxToCm(nose, ankleL, ankleR, heightCm) {
      if (!heightCm || !nose || (!ankleL && !ankleR)) return null;
      const lowestAnkleY = Math.max(ankleL ? ankleL.y : 0, ankleR ? ankleR.y : 0);
      const bodyPx = Math.abs(lowestAnkleY - nose.y);
      if (bodyPx < 50) return null;
      return heightCm / bodyPx; // cm per pixel
    }

    function midX(a, b) {
      if (a && b) return (a.x + b.x) / 2;
      if (a) return a.x;
      if (b) return b.x;
      return null;
    }

    function computeHipDropDeg(hipL, hipR) {
      if (!hipL || !hipR) return 0;
      const dy = Math.abs(hipL.y - hipR.y);
      const dx = Math.abs(hipL.x - hipR.x) || 1;
      return Math.atan2(dy, dx) * 180 / Math.PI;
    }

    function computeOverstrideRisk(hipMidX, ankle, bodyHeightPx) {
      if (hipMidX == null || !ankle) return { level: 'Low', ratio: 0 };
      const denom = Math.max(1, bodyHeightPx || 1);
      const ratio = Math.abs(ankle.x - hipMidX) / denom;

      let level = 'Low';
      if (ratio > 0.30) level = 'High';
      else if (ratio > 0.20) level = 'Moderate';

      return { level, ratio };
    }

    // Frontal ‚Äúknee medial drift‚Äù proxy:
    // For each leg, compute angle between hip->knee vector and knee->ankle vector projected in x-axis direction.
    // Larger inward kink => larger proxy angle. This is *not* true valgus angle, but useful for screening.
    function computeKneeMedialDriftProxyDeg(hipL, kneeL, ankleL, hipR, kneeR, ankleR) {
      const ang = (hip, knee, ankle) => {
        if (!hip || !knee || !ankle) return null;
        // Use a 2D angle at knee, but emphasize x deviation by weighting x more
        const ax = (hip.x - knee.x) * 1.5, ay = (hip.y - knee.y);
        const bx = (ankle.x - knee.x) * 1.5, by = (ankle.y - knee.y);
        const dot = ax*bx + ay*by;
        const na = Math.hypot(ax, ay) || 1;
        const nb = Math.hypot(bx, by) || 1;
        const cos = Math.max(-1, Math.min(1, dot/(na*nb)));
        return Math.acos(cos) * 180 / Math.PI; // ~straight is ~180
      };

      const aL = ang(hipL, kneeL, ankleL);
      const aR = ang(hipR, kneeR, ankleR);

      // Convert to "drift" = 180 - angle (bigger = more bend)
      const driftL = (aL != null) ? Math.max(0, 180 - aL) : null;
      const driftR = (aR != null) ? Math.max(0, 180 - aR) : null;

      // Show max drift as a single scalar
      const vals = [driftL, driftR].filter(v => typeof v === 'number');
      const max = vals.length ? Math.max(...vals) : 0;

      // Simple warnings (tunable)
      if (max > 18) addIssue('critical', 'Frontal: High knee medial drift (valgus proxy)');
      else if (max > 12) addIssue('warning', 'Frontal: Moderate knee medial drift (valgus proxy)');

      return max;
    }

    function calculateAngle(a, b, c) {
      const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
      let angle = Math.abs(radians * 180 / Math.PI);
      if (angle > 180) angle = 360 - angle;
      return angle;
    }

    // ============================================================
    // Issues
    // ============================================================
    function addIssue(severity, message) {
      const key = `${severity}:${message}`;
      if (detectedIssues.has(key)) return;

      detectedIssues.add(key);
      const issuesList = document.getElementById('issuesList');

      if (detectedIssues.size === 1) issuesList.innerHTML = '';

      const div = document.createElement('div');
      div.className = 'issue-item ' + severity;
      div.textContent = message;
      issuesList.insertBefore(div, issuesList.firstChild);

      while (issuesList.children.length > 6) issuesList.removeChild(issuesList.lastChild);

      setTimeout(() => detectedIssues.delete(key), 6500);
    }

    // ============================================================
    // Recording
    // ============================================================
    function toggleRecording() {
      isRecording = !isRecording;
      recordBtn.classList.toggle('recording');

      if (isRecording) {
        resetGaitAll();
        recordBtn.textContent = 'Stop Recording';
        exportBtn.disabled = true;
        statusDiv.className = 'status ready';
        statusDiv.innerHTML = 'üî¥ Recording (concurrent L/R steps)‚Ä¶';
      } else {
        recordBtn.textContent = 'Start Recording';
        exportBtn.disabled = gait.steps.length === 0;
        statusDiv.className = 'status ready';
        statusDiv.innerHTML = `‚úì Recording Stopped - ${gait.steps.length} steps captured`;
        updateChartsFromSteps();
      }
    }

    // ============================================================
    // Snapshot PNG (video + overlay)
    // ============================================================
    async function exportSnapshotPNG() {
      if (!webcam || !canvas) { alert('Camera is not running.'); return; }

      const w = canvas.width || webcam.videoWidth;
      const h = canvas.height || webcam.videoHeight;
      if (!w || !h) { alert('Snapshot unavailable (video not ready).'); return; }

      const out = document.createElement('canvas');
      out.width = w; out.height = h;
      const octx = out.getContext('2d');

      octx.drawImage(webcam, 0, 0, w, h);
      octx.drawImage(canvas, 0, 0, w, h);

      const filename = `gait_snapshot_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.png`;

      out.toBlob(async (blob) => {
        if (!blob) { alert('Failed to create snapshot.'); return; }
        statusDiv.className = 'status ready';
        statusDiv.innerHTML = 'Saving snapshot‚Ä¶';
        await saveFile(blob, filename, 'image/png');
        statusDiv.className = 'status ready';
        statusDiv.innerHTML = '‚úì Snapshot exported (iPhone: Share ‚Üí Save to Files)';
      }, 'image/png');
    }

    // ============================================================
    // XLSX export (steps only)
    // ============================================================
    async function exportToXLSX() {
      if (gait.steps.length === 0) {
        alert('No steps to export. Record a session first.');
        return;
      }

      const filename = `gait_steps_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.xlsx`;
      const wb = XLSX.utils.book_new();

      // Subject sheet
      const subjectSheetData = [
        ['Gait Biodynamics Lab - Per-Step Report'],
        ['Date', new Date().toLocaleString()],
        ['View Mode', viewMode()],
        ['Sex', subjectData.sex],
        ['Age (years)', subjectData.age],
        ['Mass (kg)', subjectData.mass],
        ['Height (cm)', subjectData.height],
        ['Notes', 'Concurrent L/R step tracking. Stance finalized at TO; swing/stride updated at next IC of same foot.']
      ];
      XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(subjectSheetData), 'Subject');

      // Steps sheet
      const rows = gait.steps.map(s => ({
        'Step #': s.idx,
        'Side': s.side,
        'IC Time (ms)': Math.round(s.tIC_ms),
        'TO Time (ms)': (typeof s.tTO_ms === 'number') ? Math.round(s.tTO_ms) : '',
        'Stance Time (s)': (typeof s.stanceTimeS === 'number') ? Number(s.stanceTimeS.toFixed(3)) : '',
        'Swing Time (s)': (typeof s.swingTimeS === 'number') ? Number(s.swingTimeS.toFixed(3)) : '',
        'Stride Length (cm)': (typeof s.strideCm === 'number') ? Number(s.strideCm.toFixed(1)) : '',
        'Knee Min (¬∞)': (typeof s.kneeMinDeg === 'number') ? Number(s.kneeMinDeg.toFixed(1)) : '',
        'Hip Drop Max (¬∞)': (typeof s.hipDropMaxDeg === 'number') ? Number(s.hipDropMaxDeg.toFixed(2)) : '',
        'Notes': s.notes || ''
      }));
      XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(rows), 'Steps');

      // Summary
      const lastN = 12;
      const slice = gait.steps.slice(-lastN);
      const nums = (k) => slice.map(s => s[k]).filter(v => typeof v === 'number' && isFinite(v));
      const mean = (arr) => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;

      const stance = nums('stanceTimeS');
      const swing = nums('swingTimeS');
      const stride = nums('strideCm');
      const knee = nums('kneeMinDeg');
      const hip = nums('hipDropMaxDeg');

      const summaryData = [
        ['Summary Window', `Last ${Math.min(lastN, gait.steps.length)} steps`],
        [],
        ['Metric','Average','Min','Max'],
        ['Stance Time (s)', stance.length ? mean(stance).toFixed(3) : '', stance.length ? Math.min(...stance).toFixed(3) : '', stance.length ? Math.max(...stance).toFixed(3) : ''],
        ['Swing Time (s)', swing.length ? mean(swing).toFixed(3) : '', swing.length ? Math.min(...swing).toFixed(3) : '', swing.length ? Math.max(...swing).toFixed(3) : ''],
        ['Stride Length (cm)', stride.length ? mean(stride).toFixed(1) : '', stride.length ? Math.min(...stride).toFixed(1) : '', stride.length ? Math.max(...stride).toFixed(1) : ''],
        ['Knee Min (¬∞)', knee.length ? mean(knee).toFixed(1) : '', knee.length ? Math.min(...knee).toFixed(1) : '', knee.length ? Math.max(...knee).toFixed(1) : ''],
        ['Hip Drop Max (¬∞)', hip.length ? mean(hip).toFixed(2) : '', hip.length ? Math.min(...hip).toFixed(2) : '', hip.length ? Math.max(...hip).toFixed(2) : '']
      ];
      XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(summaryData), 'Summary');

      const arrayBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([arrayBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

      statusDiv.className = 'status ready';
      statusDiv.innerHTML = 'Preparing XLSX‚Ä¶';
      await saveFile(blob, filename, blob.type);
      statusDiv.className = 'status ready';
      statusDiv.innerHTML = '‚úì XLSX exported (iPhone: Share ‚Üí Save to Files)';
    }

    // iOS-friendly save (Share sheet is the iOS-approved path)
    async function saveFile(blob, filename, mime) {
      const canShare = !!(navigator.canShare && navigator.share);

      if (isIOS && canShare) {
        try {
          const file = new File([blob], filename, { type: mime });
          if (navigator.canShare({ files: [file] })) {
            await navigator.share({ files: [file], title: filename, text: 'Exported from Gait Biodynamics Lab' });
            return true;
          }
        } catch (_) {}
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1500);
      return true;
    }

    // ============================================================
    // Events
    // ============================================================
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    recordBtn.addEventListener('click', toggleRecording);
    exportBtn.addEventListener('click', exportToXLSX);
    snapshotBtn.addEventListener('click', exportSnapshotPNG);

    viewModeEl.addEventListener('change', () => {
      syncModeUI();
      // Don‚Äôt reset recording automatically; but if you want stricter separation, you can:
      // if (isRecording) resetGaitAll();
    });

    window.addEventListener('load', init);
  </script>
</body>
</html>
